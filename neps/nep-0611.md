---
NEP: 611
Title: Pending Transaction Queue and Gas Keys
Authors: Robin Cheng <robin@nearone.org>, Darioush Jalali <darioush.jalali@nearone.org>
Status: Draft
DiscussionsTo: https://github.com/near/NEPs/pull/611
Type: Protocol
Version: 1.0.0
Created: 2025-05-28
LastUpdated: 2025-11-21
---

## Summary

In the near future of the Near blockchain, we foresee that via the SPICE project, transaction and receipt
execution will become decoupled from the blockchain itself; they will no longer run in lockstep.
Instead, transactions will be included in the blocks first, and then execution will follow later.

This inherently introduces a problem that we must accept transactions before we know whether they are
valid. Today, when a chunk producer produces a chunk containing a transaction, it can verify using the
current shard state that the transaction has a valid signature, has enough balance, and a valid nonce.
But as execution becomes asynchronous, we no longer have the current shard state to verify the
transactions against.

This NEP proposes a mechanism called the Pending Transaction Queue to solve this problem.

## Motivation

### Why is this worth solving?

A potential for DoS attacks exists whenever the blockchain allows anyone to submit work without paying.
Invalid transactions present such a vulnerability: if a transaction is included in a block (or more
precisely, a chunk of the block) but ends up being invalid because the sender does not have enough
balance, this transaction takes block space but cannot be charged against anyone.

A very easy-to-perform attack exists if we do nothing to mitigate the problem:

* The attacker creates two accounts, $A$ and $B$, with sufficiently many access keys each, and deploying
  a specific contract for both accounts that provides a `send_near` function.
* The attacker deposits 10 NEAR in $A$.
* The attacker then performs the following, repeatedly:
  * Submit a transaction to call A's `send_near` function, instructing it to send the account's remaining
    balance to $B$.
  * Right after, it floods the blockchain by signing and submitting many (arbitrary) transactions as $A$.
    Because execution is asynchronous, the chunk producers think that there is still enough balance in
    $A$'s account, so these transactions are accepted into chunks.
  * Some blocks later, the execution catches up, and the `send_near` function drains $A$'s account.
  * Subsequent executions of the following transactions all fail because $A$ has insufficient balance.
  * After this is done, the attacker repeats but with $A$ and $B$ swapped.

This attack can be carried out with a very simple script and requires no cost other than a single contract
call every few blocks, but this ends up filling up the blockchain, denying legitimate transactions from
being included. This is also very hard to defend against, because the attacker can simply create more
accounts. Note that this attack pattern is not the only problematic one; instead of sending away the
balance, the attacker can also delete access keys or delete the whole account.

At a high level, this solution has two key ideas:

1. Limiting the number of in-flight transactions for accounts with contracts: This aims for backwards compatibility for most use cases and also limits the amount of spam they can include on chain.

2. Allowing users with sophisticated issuance needs to prepay for gas and have many in-flight transactions. This NEP additionally includes a way to associate a single signing key and balance with an array of nonces, to provide a convenient way for parallel transaction issuance for such users.

## Specification

To solve this problem, we present two critical components which work together to ensure that all accepted
transactions are valid. At a high level, they are:

* **Access Key vs Gas Key**: In addition to Access Keys, we introduce a second kind of signing key called the Gas Key. A gas key can be funded with NEAR, and when issuing a transaction using a gas key, the transaction only consumes gas from the gas key, not from the account.
* **Pending Transaction Queue**: Chunk producers keep track of pending (accepted into a block, but not 
  executed) transactions, and ensures that transactions sent with access keys are limited in parallelism,
  whereas transactions sent with gas keys are limited to the available gas in the gas key.

We will now specify how exactly they work.

### Definition of "Pending Transactions"

In a model where execution follows but lags behind consensus, there are transactions which are accepted
into consensus and thus committed to be executed in the near future, but are not yet executed. This set
of transactions is called the *pending transactions*. We always discuss this in the context of one shard.

Note that there are two slightly different ways to treat this definition, depending on how exactly the
"execution head" (how far the execution has caught up) is defined:

* It can be defined locally as the progress of execution at a node, but this will be different between nodes.
* It can be defined deterministically as the last block whose execution result is certified by consensus.

For the purpose of this NEP, we use the latter definition, so that the notion of pending transactions is
consistent across all nodes and the determination of what transactions are eligible to be included by
a chunk producer can be verified -- even though we do not plan to implement this verification right now.

Another note is that the notion of pending transactions is anchored at a specific chunk that is being produced. In case of forks, we use the block that the chunk is being produced on top of to compute the
set of pending transactions.

Finally, this NEP does *not* depend on the implementation of SPICE. In the context where SPICE is not
yet in effect, we consider the pending transactions queue to always be empty (despite technically being
one chunk worth of transactions due to execution lagging one block behind in the current implementation),
because we can always verify the validity of all transactions at the moment of inclusion.

### Access Key vs Gas Key

We introduce a new transaction version, `TransactionV1`, which is able to either specify an access key
or a gas key. Any older transaction version is equivalent to a `TransactionV1` that specifies an access
key.

Note: The nearcore reference implementation already includes a `TransactionV1` struct, which is unused.
This struct was intended for adding support for a `priority_fee`, though this was never activated and there is no plan to activate it, so it will be removed with this NEP instead of being added to the new transaction format. This prioritizes protocol simplicity over backwards compatibility for crates that may have taken a dependency on an inactive feature.

#### Access Key Parallelism Restriction

We now restrict the ability to send multiple parallel pending transactions with Access Keys, from
accounts that also have a contract deployed.

Specifically, for any given account $A$ that has a contract deployed, the total number of access key transactions (across all access keys in the account) in the pending transaction queue whose sender is $A$
cannot exceed $P_{\mathrm {max}}$, a constant determined by the epoch; we propose $P_{\mathrm {max}} = 4$.

In other words, with traditional access keys, one cannot send more than 4 transactions from an account
with a contract deployed, before they are executed. If one wishes the send more transactions in parallel,
they would need to create a gas key.

From a UX perspective, we pick the $P_{\mathrm {max}}$ constant so that it is very likely that anyone
exceeding this parallelism is a developer who needs to send parallel transactions to the contract. In
such cases, we require them to use gas keys. This is not a pure limitation; as we will see later, a gas
key also simplifies the developer's implementation for sending parallel transactions.

Accounts that do not have a contract deployed are not restricted with any limited parallelism.

#### Gas Keys

This NEP adds Gas Keys, **conceptually** defined as the following:

```rust
struct ConceptualGasKey {
    public_key: PublicKey,
    nonces: Vec<Nonce>,
    balance: Balance,
    permission: AccessKeyPermission,
}
```

We add these operations to manipulate gas keys:

* `AddGasKey(PublicKey, AccessKeyPermission, u32)`: Creates a gas key with the given public key, permission, and number of nonces.
* `DeleteGasKey(PublicKey, u32)`: Deletes a gas key. The user must specify the same number of nonces used to create the gas key (this allows proper fee accounting without accessing state).
* `TransferToGasKey(PublicKey, Balance)`: deducts balance from the account and gives it to the gas key.

### Gas Key Actions

`AddGasKey` is verified and executed as follows:

* Account must already exist.
* Check that the same key does not already exist as a gas key. Notably, the same key can be added as an access key and a gas key as their namespace is separate.
* Requested number of nonces must be less than or equal to `GasKey::MAX_NONCES` (currently suggested as 1024). This is to limit the number of trie operations for a single action.
* Increases storage usage of associated account,
* Check that if the permission is a `FunctionCallPermission`, the allowance is `None` (unlimited
  allowance).
* A new `GasKey` entry is added to the trie, keyed by (gas key prefix, account ID, public key). The
  gas key prefix is a new trie prefix.
* For each nonce ID (from 0 to the number of nonces minus 1), store the default nonce at the trie
  prefix (gas key prefix, account ID, public key, nonce ID).
  * The default nonce is block height * 1e6, the same as the default nonce calculation for access keys.

`TransferToGasKey` is verified and executed as follows:

* The gas key must exist under the account.
* The cost of this action is the amount to fund; it is then verified the same way as a `Transfer` action.
  * See below for "gas key transactions": it is also possible to fund a gas key using a gas key; so this
    amount is not necessarily deducted straight from the account.
* To apply this action, the balance on the gas key is increased by the same amount.

`DeleteGasKey` is verified as executed as follows:

* The gas key must exist under the account.
* To apply this action, all relevant trie nodes are deleted,
* Decreases storage usage of associated account,
* The remaining balance left in the key is **burned**. (This prevent the key deletion attack.)
  * For user's benefit we may consider failing this action if the balance exceeds a certain threshold. Implementation may include a `force` flag to overrides this check.
  * Note that this does not mean that all balance in a gas key is eventually burned; one can withdraw from
    a gas key with a gas key transaction with a simple `Transfer` action.

#### Modifications to existing actions

`DeleteAccount` action will fail if the account has any associated gas keys.

#### Cost of Gas Key actions

* Cost of `AddGasKey` will be based on the cost of adding a new access key, as it is the most similar existing action. In addition, the following fees will be charged per nonce to account for further trie operations:
  * `storage_write_base`: Represent cost of adding a separate key to the trie,
  * `storage_write_key_byte * key_len`, where `key_len = MAX_ACCOUNT_ID_LEN + len(ACCOUNT_DATA_SEPARATOR) + len(PublicKey) + len(Some(u32))`: Corresponds to length of the associated trie entry's key.
    * Note `len(ACCOUNT_DATA_SEPARATOR) = 1`.
    * We use `MAX_ACCOUNT_ID_LEN` here as actual account id is not available in the action.
  * `storage_write_value_byte * len(Nonce)`: Corresponds to the length of associated trie entry's value.
* Cost of `DeleteGasKey` will be based on the cost of deleting an access key, as it is the most similar existing action. In addition, the following fees will be charged per nonce to account for further trie operations:
  * `storage_remove_base`: Represent cost of removing a key from the trie,
  * `storage_remove_key_byte * key_len`, where `key_len = MAX_ACCOUNT_ID_LEN + len(ACCOUNT_DATA_SEPARATOR) + len(PublicKey) + len(Some(u32))`: Corresponds to length of the associated trie entry's key.
    * Note `len(ACCOUNT_DATA_SEPARATOR) = 1`.
    * We use `MAX_ACCOUNT_ID_LEN` here as actual account id is not available in the action.
  * `storage_remove_ret_value_byte * len(Nonce)`: Corresponds to the length of associated trie entry's value.
* Cost of `TransferToGasKey` will be the same as `Transfer`, as it is the most similar existing action.

As an alternative, we could use the [estimator](https://github.com/near/nearcore/blob/master/docs/architecture/gas/estimator.md) to calculate these fees. However, this is known to not be accurate and ignored in favor of consistency with other fees in recent additions ([example](https://github.com/near/nearcore/issues/14160)).

#### Gas Key Transactions

`TransactionV1` reuses the fields of `TransactionV0` except replacing the `public_key` field with an enum:

```rust
enum TransactionKey {
    AccessKey { public_key: PublicKey },
    GasKey { public_key: PublicKey, nonce_index: u32 }
}
```

The semantics for gas key transactions, at the moment of execution (conversion to receipts), are:

* A gas key transaction is valid iff all of the following are true:
  * The public key corresponds to a valid gas key;
  * The gas key has enough balance to cover the total transaction cost (all costs included in config.rs
    `tx_cost`; this includes amounts included in `Transfer` actions too);
  * The nonce ID < total number of nonces for the gas key, and the nonce is a valid nonce for that nonce 
    ID (per the same nonce checks as access key);
* When converting the gas key transaction to a receipt, the same logic applies as for access key
  transactions, except
  * The transaction cost is deducted from the gas key instead of the account.
  * The new nonce is written for the specific nonce ID under the gas key.

#### Refunds from transactions originating from a gas key

This NEP suggests returning refunds to the same balance which pays for the transaction. Currently, refunds are issued to an `account_id`.

To support routing refunds to gas keys, the `ReceiptEnum` will be [extended](https://github.com/near/nearcore/blob/136acc3a524575aae1300e26901e664adb521a6f/core/primitives/src/receipt.rs#L736-L738) with `ActionV3` and `PromiseYieldV3`. These are the same as `ActionV2` and `PromiseYieldV2`, but replaces the `signer_public_key: PublicKey` field with `transaction_key: TransactionKey` as defined above.

This allows creating [balance](https://github.com/near/nearcore/blob/136acc3a524575aae1300e26901e664adb521a6f/core/primitives/src/receipt.rs#L602) and [gas](https://github.com/near/nearcore/blob/136acc3a524575aae1300e26901e664adb521a6f/core/primitives/src/receipt.rs#L655-L656) refunds with either a `Transfer` or `TransferToGasKey` action, depending on the variant of `TransactionKey` used to originate the action.

##### Refunds alternatives

1. We could route balance and gas refunds to the account balance. This trades-off user experience for simplicity of implementation and protocol: no specific changes to receipts would be needed, however the user would have to "top-off" the gas key balance more frequently.

2. Addition of `ActionV3` and `PromiseYieldV3` requires careful consideration of possible interactions with `Delegate` action and `refund_to`. It may be simpler to track the gas key for refunds by adding a `Receipt` variant, however this seems a bit out of place (as `Receipt` currently only tracks `predecessor_id`, where `ActionReceipt` tracks `signer_id` and `signer_public_key` i.e, access key).

##### Interactions with VMContext

VM execution currently [provides](https://github.com/near/nearcore/blob/136acc3a524575aae1300e26901e664adb521a6f/runtime/runtime/src/actions.rs#L74) the public key of the access key used to originate the transaction in `signer_account_pk`.
With gas keys, this may become the public key of a gas key or an access key.

As alternative, we could provide more context to the VM, allowing contracts to distinguish gas keys and access keys. Doing so provides a richer context to applications, and trades-off simplicity and future flexibility. Without having concrete use cases or limitations, the additional VM changes seem unnecessary or best left for a future NEP.

### Gas Key Pending Transaction Constraints

Unlike access key transactions, gas key transactions are not limited in parallelism; they are only limited
by the amount of gas these transactions consume. Specifically, for a gas key $G$, the total cost of 
the transactions signed with $G$ in the pending transactions must not exceed the balance of $G$
(according to the state that the pending transactions are based on).

This constraint should be good enough to cover cases of adding, funding, removing, or withdrawing from gas
keys as well. For adding and funding, we do need the execution to catch up before the newly available
balance can be used for pending transactions, which is suboptimal but correct. For withdrawing, the
action of withdrawing itself goes into the cost of the transaction and therefore is accounted for (and
note that contract execution cannot create receipts that withdraw from gas keys; only gas key
transactions can). For deletion, balance in gas keys are not refunded, so although subsequent pending
transactions may end up failing, the gas committed to those transactions are already burnt, eliminating
the opportunity for the aforementioned attack.

### Pending Transaction Queue

We would now maintain a new data structure that stores the pending transactions, called the Pending
Transaction Queue. Although it's conceptually a queue, it is stored as a collection indexed by
(account ID, transaction type), and further indexed by the block hash. Furthermore, the pending
transaction queue is stored per shard, not as a single data structure. The contents of the queue
is exactly the pending transactions according to the definition above.

The constraints are enforced as described above; we reiterate them precisely here. For each account, Let
$T_A$ be the set of transactions in the queue signed with any access key of this account, and let
$T_G$
be the set of transactions in the queue signed with any gas key of this account. The following constraints
must hold true:

* If the account has a contract deployed (as of the latest available state), then $|T_A| \le P_{\mathrm {max}}$.
* If any transaction $t\in T_A\cup T_G$ contains a `DeployContract` action, then $|T_A| \setminus \{t\}=\emptyset$. In other words, deploying a contract cannot be done in parallel with any access key
  transactions.
* The sum of the costs of all transactions in $T_A$ does not exceed the balance of the account. Here, the cost of a transaction refers to the sum of attached gas and NEAR deposit (as calculated by `total_cost` defined [here](https://github.com/near/nearcore/blob/61c087c5250566070684a624a5ea50e796f61e5f/runtime/runtime/src/config.rs#L332)). Importantly, this cost is knowable by just inspecting the actions contained in the transaction and does not depend on state or execution.
* For each gas key $g$, the sum of the costs of all transactions signed with $g$ does not exceed the
  balance of the gas key $g$.

The constraints are maintained at the time of chunk production: when producing a chunk, we only accept
transactions that would maintain these constraints. For limiting gas key transactions, we always query the
balance of the gas key from the executed state (as opposed to storing it in the queue).

To compute the pending transaction queues (one for each tracked shard) for a new block,

* Start from the queue from the previous block;
* Subtract the transactions that are included in each newly certified block;
* Add new transactions included in this block.

### Impact to Existing Protocol without SPICE

As mentioned above, this NEP applies with or without SPICE. The impact to the existing protocol is purely
positive:

* Access keys are never restricted, as the set of pending transactions is always empty.
* Gas keys allow programmatic transaction senders to more easily manage multiple nonces. Rather than
  requiring multiple access keys to be created, they just need to create a single gas key.

The implementation of gas keys before SPICE also allows programmatic users to migrate to using gas keys,
preparing them for when SPICE is launched.

## Security Implications

### DoS Attack Prevention

The primary security benefit of this NEP is preventing the DoS attack vector described in the Motivation section. By restricting access key parallelism for contract accounts and requiring gas keys to be pre-funded, we ensure that attackers cannot flood the blockchain with transactions that appear valid at inclusion time but become invalid during execution. All accepted transactions have committed resources that can be charged for gas consumption.

### Balance Burning on Gas Key Deletion

When a gas key is deleted, any remaining balance is burned rather than refunded. This prevents an attack where an adversary attempts to include non-fee paying transactions on chain by submitting many transactions yet reclaiming the balance on deletion.

## Reference Implementation

* [Initial implementation of gas key trie modifications](https://github.com/near/nearcore/pull/13687)
* [Initial implementation of gas key actions](https://github.com/near/nearcore/pull/14532)
* [Work in progress implementation of actions and refund receipts](https://github.com/near/nearcore/pull/14521)

## Alternatives

One alternative to the gas key design is to introduce a `SenderReservedBalance`: under this model, the sender's account reserves a portion of its NEAR balance specifically for gas on future transactions.

The runtime would check that the sender has enough reserved funds to cover both the gas cost and the required minimum balance, thereby enforcing validity without requiring additional trie keys. While initially it seems simpler, this approach comes with significant and subtle drawbacks:

* Modifies the semantics of the account's main balance, requiring checks that contract execution doesn't deplete the balance lower than `SenderReservedBalance`, potentially breaking existing assumptions about how balance operates.
* Contract execution can lead to deletion of access keys and accounts (which transfers the balance to a beneficiary). The chunk producer cannot predict this. Further, such actions can be originated from a different account.
* When transferring balance to another account, the `Transfer` transaction's cost currently includes the amount being transferred, since the conversion to a receipt requires deducting that amount of balance. With sender reserved balance, we must change it so that if a transaction includes a `Transfer` action but there's not enough balance to cover the amount being transferred, the gas portion of the transaction is still deducted.

In contrast, the gas keys solution is semantically additive, does not modify semantics of existing account balance, and also provides improved user experience for concurrent transaction issuance via `nonce_index`.

### Vector nonce implementation

As an alternative to having a separate trie key for each nonce, we could store all the nonces for a given gas key under a single trie key in a vector.

With the vector implementation, the number of trie reads will decrease from 2 to 1, however the amount of data read from the value will be larger and depend on the number of nonces.

This means we would have to charge users using more nonces a higher fee not only during addition and deletion, but also when using the gas key to sign a transaction.
 
The larger amount of data read must also be included in state witnesses.

Additionally, in the future it may be easier to reason about processing transactions in parallel when the trie keys for different nonces do not overlap.

## Consequences

### Positive

* Enables implementing SPICE without potential for users to create unbounded spam.
* Enhanced nonce management enabling parallel transaction submission for sophisticated users.

### Neutral

* N/A

### Negative

* Adds complexity to protocol and implementation.

### Backwards Compatibility

* Adding `TransactionV1` does not change the semantics for `TransactionV0`. Users can continue to submit their transactions as such.
* Adding new keys to the trie may require modifications for downstream parsers, indexers.
* Existing use cases may assume they can submit an unbounded number of in-flight transactions. As changes only impact accounts with contracts, the impact of this is assumed to be low.
* `VMContext` exposes the access key's public key to the contracts. Going forward, this could be a public key corresponding to either a gas key or a public key.

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
