---
NEP: 611
Title: Pending Transaction Queue and Gas Keys
Authors: Robin Cheng <robin@nearone.org>, Darioush Jalali <darioush.jalali@nearone.org>
Status: Draft
DiscussionsTo: https://github.com/near/NEPs/pull/611
Type: Protocol
Version: 1.1.0
Created: 2025-05-28
LastUpdated: 2025-12-18
---

## Summary

In the near future of the Near blockchain, we foresee that via the SPICE project, transaction and receipt
execution will become decoupled from the blockchain itself; they will no longer run in lockstep.
Instead, transactions will be included in the blocks first, and then execution will follow later.

This inherently introduces a problem that we must accept transactions before we know whether they are
valid. Today, when a chunk producer produces a chunk containing a transaction, it can verify using the
current shard state that the transaction has a valid signature, has enough balance, and a valid nonce.
But as execution becomes asynchronous, we no longer have the current shard state to verify the
transactions against.

This NEP proposes a mechanism called the Pending Transaction Queue to solve this problem.

## Motivation

### Why is this worth solving?

A potential for DoS attacks exists whenever the blockchain allows anyone to submit work without paying.
Invalid transactions present such a vulnerability: if a transaction is included in a block (or more
precisely, a chunk of the block) but ends up being invalid because the sender does not have enough
balance, this transaction takes block space but cannot be charged against anyone.

A very easy-to-perform attack exists if we do nothing to mitigate the problem:

* The attacker creates two accounts, $A$ and $B$, with sufficiently many access keys each, and deploying
  a specific contract for both accounts that provides a `send_near` function.
* The attacker deposits 10 NEAR in $A$.
* The attacker then performs the following, repeatedly:
  * Submit a transaction to call A's `send_near` function, instructing it to send the account's remaining
    balance to $B$.
  * Right after, it floods the blockchain by signing and submitting many (arbitrary) transactions as $A$.
    Because execution is asynchronous, the chunk producers think that there is still enough balance in
    $A$'s account, so these transactions are accepted into chunks.
  * Some blocks later, the execution catches up, and the `send_near` function drains $A$'s account.
  * Subsequent executions of the following transactions all fail because $A$ has insufficient balance.
  * After this is done, the attacker repeats but with $A$ and $B$ swapped.

This attack can be carried out with a very simple script and requires no cost other than a single contract
call every few blocks, but this ends up filling up the blockchain, denying legitimate transactions from
being included. This is also very hard to defend against, because the attacker can simply create more
accounts. Note that this attack pattern is not the only problematic one; instead of sending away the
balance, the attacker can also delete access keys or delete the whole account.

At a high level, this solution has two key ideas:

1. Limiting the number of in-flight transactions for accounts with contracts: This aims for backwards compatibility for most use cases and also limits the amount of spam they can include on chain.

2. Allowing users with sophisticated issuance needs to prepay for gas and have many in-flight transactions. This NEP additionally includes a way to associate a single signing key and balance with an array of nonces, to provide a convenient way for parallel transaction issuance for such users.

## Specification

To solve this problem, we present two critical components which work together to ensure that all accepted
transactions are valid. At a high level, they are:

* **Access Key vs Gas Key**: We introduce a new type of access key, which we will call "Gas Key". A gas key can be funded with NEAR, and when issuing a transaction using a gas key, the transaction only consumes gas from the gas key, not from the account.
* **Pending Transaction Queue**: Chunk producers keep track of pending (accepted into a block, but not 
  executed) transactions, and ensures that transactions sent with access keys are limited in parallelism,
  whereas transactions sent with gas keys are limited to the available gas in the gas key.

We will now specify how exactly they work.

### Definition of "Pending Transactions"

In a model where execution follows but lags behind consensus, there are transactions which are accepted
into consensus and thus committed to be executed in the near future, but are not yet executed. This set
of transactions is called the *pending transactions*. We always discuss this in the context of one shard.

Note that there are two slightly different ways to treat this definition, depending on how exactly the
"execution head" (how far the execution has caught up) is defined:

* It can be defined locally as the progress of execution at a node, but this will be different between nodes.
* It can be defined deterministically as the last block whose execution result is certified by consensus.

For the purpose of this NEP, we use the latter definition, so that the notion of pending transactions is
consistent across all nodes and the determination of what transactions are eligible to be included by
a chunk producer can be verified -- even though we do not plan to implement this verification right now.

Another note is that the notion of pending transactions is anchored at a specific chunk that is being produced. In case of forks, we use the block that the chunk is being produced on top of to compute the
set of pending transactions.

Finally, this NEP does *not* depend on the implementation of SPICE. In the context where SPICE is not
yet in effect, we consider the pending transactions queue to always be empty (despite technically being
one chunk worth of transactions due to execution lagging one block behind in the current implementation),
because we can always verify the validity of all transactions at the moment of inclusion.

### Access Key vs Gas Key

We introduce a new transaction version, `TransactionV1`, which is able to either specify an access key
or a gas key. Any older transaction version is equivalent to a `TransactionV1` that specifies an access
key.

Note: The nearcore reference implementation already includes a `TransactionV1` struct, which is unused.
This struct was intended for adding support for a `priority_fee`, though this was never activated and there is no plan to activate it, so it will be removed with this NEP instead of being added to the new transaction format. This prioritizes protocol simplicity over backwards compatibility for crates that may have taken a dependency on an inactive feature.

#### Access Key Parallelism Restriction

We now restrict the ability to send multiple parallel pending transactions with Access Keys, from
accounts that also have a contract deployed.

Specifically, for any given account $A$ that has a contract deployed, the total number of access key transactions (across all access keys in the account) in the pending transaction queue whose sender is $A$
cannot exceed $P_{\mathrm {max}}$, a constant determined by the epoch; we propose $P_{\mathrm {max}} = 4$.

In other words, with traditional access keys, one cannot send more than 4 transactions from an account
with a contract deployed, before they are executed. If one wishes the send more transactions in parallel,
they would need to create a gas key.

From a UX perspective, we pick the $P_{\mathrm {max}}$ constant so that it is very likely that anyone
exceeding this parallelism is a developer who needs to send parallel transactions to the contract. In
such cases, we require them to use gas keys. This is not a pure limitation; as we will see later, a gas
key also simplifies the developer's implementation for sending parallel transactions.

Accounts that do not have a contract deployed are not restricted with any limited parallelism.

#### Gas Keys

This NEP adds Gas Keys, **conceptually** defined as the following:

```rust
struct ConceptualGasKey {
    public_key: PublicKey,
    nonces: Vec<Nonce>,
    balance: Balance,
    permission: AccessKeyPermission,
}
```

We add these operations to manipulate gas keys:

* `AddGasKey(PublicKey, AccessKeyPermission, u32)`: Creates a gas key with the given public key, permission, and number of nonces.
* `DeleteGasKey(PublicKey, u32)`: Deletes a gas key. The user must specify the same number of nonces used to create the gas key (this allows proper fee accounting without accessing state).
* `TransferToGasKey(PublicKey, Balance)`: deducts balance from the account and gives it to the gas key.
* `TransferFromGasKey(PublicKey, Balance)`: deducts the balance from the gas key and gives it to the account.

Since gas keys are a kind of access key, they share a namespace. This means that the user is not allowed to create a gas key with the same public key as an existing access key. This is important in refund handling.

### Gas Key Actions

`AddGasKey` is verified and executed as follows:

* Account must already exist.
* Check that the same key does not already exist as a gas key or access key.
* Requested number of nonces must be less than or equal to `GasKey::MAX_NONCES` (currently suggested as 1024). This is to limit the number of trie operations for a single action.
* Increases storage usage of associated account,
* Check that if the permission is a `FunctionCallPermission`, the allowance is `None` (unlimited
  allowance).
* A new `GasKey` entry is added to the trie.
* For each nonce ID (from 0 to the number of nonces minus 1), store the default nonce in the trie.
* The default nonce is block height * 1e6, the same as the default nonce calculation for access keys.

`TransferToGasKey` is verified and executed as follows:

* The gas key must exist under the account.
* The cost of this action is the amount to fund; it is then verified the same way as a `Transfer` action.
* To apply this action, the balance on the gas key is increased by the same amount.

`TransferFromGasKey` is verified and executed as follows:

* The cost of this action is similar to the cost of `Transfer`, however the deposit amount is not included.
* The specified gas key must have sufficient balance to perform the transfer from.
* To apply this action, the balance on the gas key is decreased by the specified amount, which is credited to the account balance.

`DeleteGasKey` is verified as executed as follows:

* The gas key must exist under the account.
* To apply this action, all relevant trie nodes are deleted,
* Decreases storage usage of associated account,
* The remaining balance left in the key is **burned**. (This prevent the key deletion attack, in case in the future gas keys can be deleted programmatically.)
  * For user's benefit we may consider failing this action if the balance exceeds a certain threshold. The implementation may include a `force` flag that overrides this check.
  * Note that this does not mean that all balance in a gas key is eventually burned; one can withdraw from
    a gas key using the `TransferFromGasKey` action.

#### Modifications to existing actions

`DeleteAccount` action will fail if the account has any associated gas keys.

`DeleteKey` is not allowed to delete gas keys.

`AddKey` action will fail if the public key is already registered as a gas key. It can also not be used to add a gas key.


#### Cost of Gas Key actions

* Cost of `AddGasKey` will be based on the cost of adding a new access key, as it is the most similar existing action. In addition, appropriate fees will be charged per nonce to account for further trie operations.
* Cost of `DeleteGasKey` will be based on the cost of deleting an access key, as it is the most similar existing action. In addition, appropriate fees will be charged per nonce to account for further trie operations.
* Cost of `TransferToGasKey` and `TransferFromGasKey` will be the same as `Transfer`, as it is the most similar existing action.

As an alternative, we could use the [estimator](https://github.com/near/nearcore/blob/master/docs/architecture/gas/estimator.md) to calculate these fees. However, this is known to not be accurate and ignored in favor of consistency with other fees in recent additions ([example](https://github.com/near/nearcore/issues/14160)).

#### Gas Key Transactions

`TransactionV1` reuses the fields of `TransactionV0` except replacing the `nonce` field with an enum:

```rust
enum TransactionNonce {
    Nonce { nonce: Nonce },
    GasKeyNonce { nonce: Nonce, nonce_index: u32 }
}
```

Transactions that specify a `GasKeyNonce` will use gas keys, and transactions that specify `Nonce` will use access keys.

The cost of a transaction (as set in [`calculate_tx_cost`](https://github.com/near/nearcore/blob/4fefbdf90c645506beb562ecf87e84f6387aef2f/runtime/runtime/src/config.rs#L330)) will be split into:

* **Gas key cost**: `burnt_amount + remaining_gas_amount`. (This includes the gas burnt for converting this tx to a receipt and pre-paid gas for function calls). In case of `TransferFromGasKey`, this includes the amount to withdraw from the gas key as well.
* **Deposit**: Cost of transaction's actions.

The semantics for gas key transactions, at the moment of execution (conversion to receipts), are:

* A gas key transaction is valid iff all of the following are true:
  * The public key corresponds to a valid gas key;
  * The gas key has enough balance to cover **gas key cost**.
  * The account balance can cover **deposit**; this includes amounts included in `Transfer` actions.
  * The nonce ID < total number of nonces for the gas key, and the nonce is a valid nonce for that nonce 
    ID (per the same nonce checks as access key);
* When converting the gas key transaction to a receipt, the same logic applies as for access key
  transactions, except
  * The gas key cost is deducted from the gas key instead of the account. (Deposit cost is still deducted from account).
  * The new nonce is written for the specific nonce ID under the gas key.


##### What happens if account cannot cover deposit?

Transaction processing is extended with a new failure case: `InvalidTxError::NotEnoughBalanceForDeposit`. In case the account programmatically sends away its balance we need to be able to charge the user a fee, otherwise we will have the spam issue this NEP intends to prevent. With honest chunk producers, this case only happens when using a gas key. 

*Note*: As of the current date, `nearcore` ignores failed transactions in processing. After `ProtocolFeature::InvalidTxGenerateOutcomes`, invalid transactions impact the outcome but not the state. Therefore, this NEP also introduces the change that failed transactions may update the state (to charge for gas).

#### Refunds from transactions originating from a gas key

This NEP suggests returning refunds to the same balance which pays for the transaction. Therefore [*balance refunds*](https://github.com/near/nearcore/blob/4fefbdf90c645506beb562ecf87e84f6387aef2f/core/primitives/src/receipt.rs#L555-L559) will be issued to the account balance, and [*gas refunds*](https://github.com/near/nearcore/blob/4fefbdf90c645506beb562ecf87e84f6387aef2f/core/primitives/src/receipt.rs#L596-L604) will be issued to the gas key.

This is compatible with the existing receipt refunds, which use signer_id to [refund access key allowances](https://github.com/near/nearcore/blob/4fefbdf90c645506beb562ecf87e84f6387aef2f/runtime/runtime/src/actions.rs#L418-L428).

As there is no overlap between gas key and access keys, a gas refund can be issued to the gas key's balance (without creating ambiguity if it should refund an access key's allowance instead).

*Note*: We only allow `None` allowance for a `FunctionCallPermission` in gas keys.

Additionally, this is compatible with `refund_to`, which only [impacts](https://github.com/near/nearcore/blob/4fefbdf90c645506beb562ecf87e84f6387aef2f/core/primitives/src/receipt.rs#L764-L766) balance refunds.

##### Refunds alternatives

1. We could route balance and gas refunds to the account balance. This trades-off user experience for simplicity of implementation and protocol: no specific changes to receipts would be needed, however the user would have to "top-off" the gas key balance more frequently.

2. We could add `ActionV3` and `PromiseYieldV3`, however this requires careful consideration of possible interactions with `Delegate` action and `refund_to`.

3. We could track the gas key for refunds by adding a `Receipt` variant, however this seems a bit out of place (as `Receipt` currently only tracks `predecessor_id`, where `ActionReceipt` tracks `signer_id` and `signer_public_key` i.e, access key).

##### Interactions with VMContext

VM execution currently [provides](https://github.com/near/nearcore/blob/136acc3a524575aae1300e26901e664adb521a6f/runtime/runtime/src/actions.rs#L74) the public key of the access key used to originate the transaction in `signer_account_pk`.
With gas keys, this may become the public key of a gas key or an access key.

As alternative, we could provide more context to the VM, allowing contracts to distinguish gas keys and access keys. Doing so provides a richer context to applications, and trades-off simplicity and future flexibility. Without having concrete use cases or limitations, the additional VM changes seem unnecessary or best left for a future NEP.

### Gas Key Pending Transaction Constraints

Unlike access key transactions, gas key transactions are not limited in parallelism; they are only limited
by the amount of gas these transactions consume. Specifically, for a gas key $G$, the **gas key cost** of 
the transactions signed with $G$ in the pending transactions must not exceed the balance of $G$
(according to the state that the pending transactions are based on).

This constraint should be good enough to cover cases of adding, funding, removing, or withdrawing from gas
keys as well. For adding and funding, we do need the execution to catch up before the newly available
balance can be used for pending transactions, which is suboptimal but correct. 
Note that contract execution cannot create receipts that withdraw from gas keys; only gas key
transactions can. For deletion, balance in gas keys are not refunded, so although subsequent pending
transactions may end up failing, the gas committed to those transactions are already burnt, eliminating
the opportunity for the aforementioned attack.

### Pending Transaction Queue

We would now maintain a new data structure that stores the pending transactions, called the Pending
Transaction Queue. Although it's conceptually a queue, it is stored as a collection indexed by
(account ID, transaction type), and further indexed by the block hash. Furthermore, the pending
transaction queue is stored per shard, not as a single data structure. The contents of the queue
is exactly the pending transactions according to the definition above.

The constraints are enforced as described above; we reiterate them precisely here. For each account, Let
$T_A$ be the set of transactions in the queue signed with any access key of this account, and let
$T_G$
be the set of transactions in the queue signed with any gas key of this account. The following constraints
must hold true:

* If the account has a contract deployed (as of the latest available state), then $|T_A| \le P_{\mathrm {max}}$.
* If any transaction $t\in T_A\cup T_G$ contains a `DeployContract` action, then $|T_A| \setminus \{t\}=\emptyset$. In other words, deploying a contract cannot be done in parallel with any access key
  transactions. The same applies to `UseGlobalContract`, `DeterministicStateInit`, and `Delegate` with inner deploy-like actions.
* The sum of **total costs** of all transactions in $T_A$ plus the sum of **deposit costs** of all transactions in $T_G$ does not exceed the account balance.
* For each gas key $g$, the sum of the **gas key costs** of all transactions signed with $g$ does not exceed the balance of $g$.
* Importantly, these costs can be calculated from the gas price and inspecting the actions contained in the transaction (does not depend on state or execution).


The constraints are maintained at the time of chunk production: when producing a chunk, we only accept
transactions that would maintain these constraints. For limiting gas key transactions, we always query the
balance of the gas key from the executed state (as opposed to storing it in the queue).

To compute the pending transaction queues (one for each tracked shard) for a new block,

* Start from the queue from the previous block;
* Subtract the transactions that are included in each newly certified block;
* Add new transactions included in this block.

### Trie storage

To facilitate the above design, gas keys must be stored in the trie. They are stored under the same `TrieKey` as a normal access key:

```rust
    AccessKey {
        account_id: AccountId,
        public_key: PublicKey,
    } // uses col::ACCESS_KEY
```

Then, gas keys can be stored as a specific kind of a newly added `AccessKeyPermission` variant:

```rust
pub struct AccessKey {
    pub nonce: Nonce,
    pub permission: AccessKeyPermission,
}
pub enum AccessKeyPermission {
    // Already exists
    FunctionCall(FunctionCallPermission),
    FullAccess,

    // Newly added
    GasKeyFunctionCall(GasKeyInfo, FunctionCallPermission),
    GasKeyFullAccess(GasKeyInfo),
}
```

Individual nonces are stored under the following `TrieKey` as `u64` values:

```rust
    GasKeyNonce {
        account_id: AccountId,
        public_key: PublicKey,
        nonce_index: u32
    } // also uses col::ACCESS_KEY
```

### RPC and `StateChanges` modifications

Gas keys are returned as other access keys using `view_access_key_list`, and `view_access_key` queries. They will show with the newly introduced `AccessKeyPermission` enum variants that contain gas key info (i.e., balance and number of nonces).

New queries will be introduced for gas key nonces, such as `view_gas_key_nonces`.

As an alternative, we could gather and return all nonces as part of existing queries. However, this changes the return types of existing API and potentially makes them more expensive.


### Impact to Existing Protocol without SPICE

As mentioned above, this NEP applies with or without SPICE. The impact to the existing protocol is purely
positive:

* Normal access keys are never restricted, as the set of pending transactions is always empty.
* Gas keys allow programmatic transaction senders to more easily manage multiple nonces. Rather than
  requiring multiple access keys to be created, they just need to create a single gas key.

The implementation of gas keys before SPICE also allows programmatic users to migrate to using gas keys,
preparing them for when SPICE is launched.

## Security Implications

### DoS Attack Prevention

The primary security benefit of this NEP is preventing the DoS attack vector described in the Motivation section. By restricting access key parallelism for contract accounts and requiring gas keys to be pre-funded, we ensure that attackers cannot flood the blockchain with transactions that appear valid at inclusion time but become invalid during execution. All accepted transactions have committed resources that can be charged for gas consumption.

### Balance Burning on Gas Key Deletion

When a gas key is deleted, any remaining balance is burned rather than refunded. This prevents an attack where an adversary attempts to include non-fee paying transactions on chain by submitting many transactions yet reclaiming the balance on deletion.

## Reference Implementation

* [Initial implementation of gas key trie modifications](https://github.com/near/nearcore/pull/13687)
* [Initial implementation of gas key actions](https://github.com/near/nearcore/pull/14532)
* [Work in progress implementation of actions and refund receipts](https://github.com/near/nearcore/pull/14521)

## Alternatives

One alternative to the gas key design is to introduce a `SenderReservedBalance`: under this model, the sender's account reserves a portion of its NEAR balance specifically for gas on future transactions.

The runtime would check that the sender has enough reserved funds to cover both the gas cost and the required minimum balance, thereby enforcing validity without requiring additional trie keys. While initially it seems simpler, this approach comes with significant and subtle drawbacks:

* Contract execution can lead to deletion of access keys. This creates a problem for sharing a single reserved gas balance between multiple access keys.

  The specific case to consider is where the `Account` balance is not sufficient to pay for the transaction (i.e., `InvalidTxError::NotEnoughBalanceForDeposit` is occurring). Recall this happens if the contract sends away its balance in a prior block as the chunk producer cannot predict it. If the contract also programmatically deletes the signing key, it is not possible for the executor to distinguish this (which should charge for gas) from an unauthorized transaction using an incorrect key (which is not chargeable) only by using the current state.

* Modifies the semantics of the account's main balance, requiring checks that contract execution doesn't deplete the balance lower than `SenderReservedBalance`, potentially breaking existing assumptions about how balance operates.

In contrast, the gas keys solution solves the deleted key problem, does not modify semantics of existing account balance, and also provides improved user experience for concurrent transaction issuance via `nonce_index`.

### Storing entire vector nonce of nonces in a single trie key

As an alternative to having a separate trie key for each nonce, we could store all the nonces for a given gas key under a single trie key in a vector.

With the vector implementation, the number of trie reads will decrease from 2 to 1, however the amount of data read from the value will be larger and depend on the number of nonces.

This means we would have to charge users using more nonces a higher fee not only during addition and deletion, but also when using the gas key to sign a transaction.
 
The larger amount of data read must also be included in state witnesses.

Additionally, in the future it may be easier to reason about processing transactions in parallel when the trie keys for different nonces do not overlap.

### Alternate design for transaction parallelism (NEP-522)

[NEP-522](https://github.com/near/NEPs/pull/522/files) describes an approach to transaction deduplication based on random nonces and tracking state of recently seen transaction hashes in the trie.

This NEP takes an approach which does not require writing to the trie. Additionally, it does not require maintaining a data structure with historical blocks.

### Alternate possibilities for actions

* It is possible for the `DeleteGasKey` action to issue a refund to the account. If we refund gas on deletion, the `TransferFromGasKey` action may no longer be needed (we can have users delete and recreate their gas key to withdraw). Taking this alternative means in the future, contracts cannot programmatically delete gas keys.

* It is possible for the `DeleteAccount` action to succeed but silently delete gas keys, however this risks accidental loss of funds due to user error. As this action can be performed programmatically already, we cannot issue a refund for gas key balances during account deletion.

### Alternative trie storage scheme

As an alternative, gas keys may be stored under a separate trie column using the following `TrieKey`:

```rust
    GasKeyNonce {
        account_id: AccountId,
        public_key: PublicKey,
        nonce_index: Option<u32>
    } // uses new column col::GAS_KEY
```

In this scheme, the gas key data is stored with `nonce_index: None` and for the individual nonces are stored by with `nonce_index: Some(index)`.

The advantage of this alternative is simplicity and a more additive implementation. The downside is processing refunds, and adding new access or gas keys would incur an additional trie read (which also consumes space in the state witness).

While we can consider adding keys relatively uncommon, gas refunds are fairly common. This change would require 3 instead of 2 trie accesses which increases the impact of these receipts on state witness size by 50%.

## Consequences

### Positive

* Enables implementing SPICE without potential for users to create unbounded spam.
* Enhanced nonce management enabling parallel transaction submission for sophisticated users.

### Neutral

* N/A

### Negative

* Adds complexity to protocol and implementation.

### Backwards Compatibility

* Adding `TransactionV1` does not change the semantics for `TransactionV0`. Users can continue to submit their transactions as such.
* Adding new keys to the trie may require modifications for downstream parsers, indexers.
* Existing use cases may assume they can submit an unbounded number of in-flight transactions. As changes only impact accounts with contracts, the impact of this is assumed to be low.
* `VMContext` exposes the access key's public key to the contracts. Going forward, this could be a public key corresponding to either a gas key or a public key.

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
