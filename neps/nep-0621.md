---
NEP: 621
Title: Vault NEP
Authors: JY Chew <edwardchew97@gmail.com>, Lee Hoe Mun <leehoemun@gmail.com>, Wade <wz.lim.00@gmail.com>, Steve Kok <kokchoquan@gmail.com>
Status: Approved
DiscussionsTo: https://github.com/nearprotocol/neps/pull/0000
Type: Contract Standard
Requires: 141
Version: 1.0.0
Created: 2025-08-08
LastUpdated: 2025-08-08
---

## Summary

This NEP proposes a standardized interface for implementing vault contracts on the NEAR Protocol, drawing inspiration from the ERC-4626 standard widely used on Ethereum. A vault contract allows users to deposit an underlying fungible token (FT) into the vault, in exchange for which the vault issues shares that represent proportional ownership of the vault’s assets.

The underlying asset could be any NEP-141 compliant fungible token, such as a stablecoin or yield-bearing token. When deposited, the vault mints new shares to the depositor based on the current exchange rate between the vault’s total assets and total shares in circulation. Conversely, when a user redeems shares, the vault burns those shares and returns the equivalent amount of the underlying asset to the user.

The issued shares themselves are also NEP-141 compliant fungible tokens, enabling them to be freely transferred between accounts or traded on decentralized exchanges (DEXs). This compatibility allows vault shares to be integrated into broader DeFi ecosystems, enabling use cases such as collateral in lending protocols, liquidity provision, or composable yield strategies.

By standardizing the vault interface, this NEP aims to improve interoperability, reduce integration costs, and encourage consistent, secure practices for vault implementation across the NEAR ecosystem.

## Motivation

Vault contracts are a fundamental building block in modern DeFi, enabling users to pool assets for yield generation, liquidity provision, or other strategies while receiving tokenized shares that represent their proportional ownership. However, without a standardized interface, each vault implementation on NEAR may expose different method names, return formats, and accounting mechanisms, creating unnecessary friction for developers, integrators, and auditors.

A consistent vault standard, inspired by ERC-4626, would provide multiple benefits:

-   Interoperability – Wallets, DEXs, lending protocols, and other DeFi applications can integrate with any compliant vault without custom logic for each implementation.

-   Reduced Integration Costs – Developers and projects save time and resources by building once against the standard interface rather than creating one-off integrations.

-   Ecosystem Growth – Standardized vaults make it easier for new projects to leverage existing liquidity and composability, accelerating adoption across the NEAR DeFi ecosystem.

By introducing this NEP, we aim to align vault design on NEAR with proven best practices from other blockchain ecosystems while optimizing for the unique features and requirements of NEP-141 fungible tokens.

## Specification

### Contract Interface

The contract should implement the VaultCore trait.

```rust
/// Specification for a fungible token vault that issues NEP-141 compliant shares.
///
/// A FungibleTokenVault accepts deposits of an underlying NEP-141 compliant asset
/// and issues NEP-141 compliant "shares" in return. These shares can be transferred
/// and traded like any other NEP-141 token.
///
/// This trait extends:
/// - [`FungibleTokenCore`] to provide NEP-141 functionality for shares.
/// - [`FungibleTokenReceiver`] to receive the underlying NEP-141 assets
pub trait VaultCore:
    FungibleTokenCore + FungibleTokenReceiver
{
    // ----------------------------
    // Asset Information
    // ----------------------------

    /// Returns the [`AccountId`] of the underlying asset token contract.
    ///
    /// ERC4626 original function name: asset()
    ///
    /// The underlying asset **must** be NEP-141 compliant.
    /// Implementations should store this as an immutable configuration value.
    fn asset_contract_id(&self) -> AccountId;

    /// Returns the total amount of underlying assets represented by all shares in existence.
    ///
    /// ERC4626 original function name: totalAssets()
    ///
    /// **Important:**
    /// - Represents the vault's *total managed value*, not just assets held in the contract.
    /// - If assets are staked, lent, swapped, or deployed elsewhere, this should return
    ///   an **estimated total equivalent value**.
    /// - Must be denominated in the same units as [`Self::asset_contract_id`].
    /// - If the vault applies any deposit or withdrawal fees, `total_asset_amount` must reflect the net value of
    ///   all shares, i.e. the aggregate worth of the vault’s holdings after deducting all applicable fees.
    fn total_asset_amount(&self) -> U128;

    // ----------------------------
    // Conversion Helpers
    // ----------------------------

    /// Converts an amount of underlying assets to the equivalent number of shares.
    ///
    /// ERC4626 original function name: convertToShares(uint256 assets)
    ///
    /// This is a **purely view-only estimation** that:
    /// - Does not update state.
    /// - Ignores user-specific constraints such as deposit limits or fees.
    ///
    /// # Panics / Fails
    /// - The `convert_to_shares` method must never panic.
    ///   It should always return the corresponding amount of shares for the given assets,
    ///   or `0` if conversion is not possible.
    ///
    /// See also: [`Self::preview_deposit_shares`] for a version that accounts for limits and fees.
    fn convert_to_shares(&self, asset_amount: U128) -> U128;

    /// Converts an amount of shares to the equivalent amount of underlying assets.
    ///
    /// ERC4626 original function name: convertToAssets(uint256 shares)
    ///
    /// This is a **purely view-only estimation** that:
    /// - Does not update state.
    /// - Ignores withdrawal restrictions, fees, or penalties.
    ///
    /// # Panics / Fails
    /// - The `convert_to_asset_amount` method must never panic.
    ///   It should always return the corresponding amount of assets for the given shares,
    ///   or `0` if conversion is not possible.
    ///
    /// See also: [`Self::preview_redeem_amount`] for a version that accounts for real-world constraints.
    fn convert_to_asset_amount(&self, shares: U128) -> U128;

    // ----------------------------
    // Deposit / Redemption Limits
    // ----------------------------

    /// Returns the maximum amount of underlying assets that `receiver_id` can deposit.
    ///
    /// ERC4626 original function name: maxDeposit(address receiver)
    ///
    /// This may depend on:
    /// - Vault capacity.
    /// - User-specific limits.
    /// - Current on-chain conditions.
    ///
    /// # Panics / Fails
    /// - The `max_deposit_amount` method must never panic.
    ///   It should return the maximum amount of assets that can be deposited for the given account,
    ///   or `0` if deposits are not currently allowed.
    ///
    /// Implementations should return `U128::MAX` to signal "unlimited" deposits.
    fn max_deposit_amount(&self, receiver_id: AccountId) -> U128;

    /// Simulates depositing exactly `assets` into the vault and returns the number of shares
    /// that would be minted to the receiver.
    ///
    /// ERC4626 original function name: previewDeposit(uint256 assets)
    ///
    /// Differs from [`Self::convert_to_shares`] by accounting for:
    /// - Per-user deposit limits.
    /// - Protocol-specific deposit fees.
    ///
    /// # Panics / Fails
    /// - The `preview_deposit_shares` method must never panic.
    ///   It should return the number of shares that would be minted for the given deposit amount,
    ///   or `0` if deposits are not currently allowed.
    ///
    fn preview_deposit_shares(&self, asset_amount: U128) -> U128;

    /// Returns the maximum number of shares that `receiver_id` can mint.
    ///
    /// ERC4626 original function name: maxMint(address receiver)
    ///
    /// This may depend on:
    /// - Vault capacity.
    /// - User-specific limits.
    /// - Current on-chain conditions.
    ///
    /// # Panics / Fails
    /// - The `max_mint_shares` method must never panic.
    ///   It should return the maximum number of shares that can be minted for the given account,
    ///   or `0` if minting is not currently allowed.
    ///
    /// Implementations should return `U128::MAX` to signal "unlimited" minting.
    fn max_mint_shares(&self, receiver_id: AccountId) -> U128;

    /// Simulates minting exactly `shares` and returns the amount of underlying assets
    /// that would be required.
    ///
    /// ERC4626 original function name: previewMint(uint256 shares)
    ///
    /// Differs from [`Self::convert_to_asset_amount`] by accounting for:
    /// - Per-user minting limits.
    /// - Protocol-specific minting fees.
    ///
    /// Useful for frontends to estimate the cost of minting shares.
    ///
    /// # Panics / Fails
    /// - The `preview_asset_amount_required_to_mint_shares` method must never panic.
    ///   Instead, it should return the maximum possible mint amount, or `0` if minting is currently not permitted.
    fn preview_asset_amount_required_to_mint_shares(&self, shares: U128) -> U128;

    /// Returns the maximum number of shares that `owner_id` can redeem.
    ///
    /// ERC4626 original function name: maxRedeem(address owner)
    ///
    /// This may depend on:
    /// - The owner's current share balance.
    /// - Vault withdrawal restrictions.
    /// - Lock-up periods or cooldowns.
    ///
    /// # Panics / Fails
    /// - The `max_redeem_shares` method must never panic.
    ///   It should return the maximum number of shares that can be redeemed by the given account,
    ///   or `0` if redemption is not currently allowed.
    ///
    /// Implementations should return `0` if redemptions are currently disabled for the owner.
    fn max_redeem_shares(&self, owner_id: AccountId) -> U128;

    /// Returns the maximum amount of assets that `owner_id` can withdraw.
    ///
    /// ERC4626 original function name: maxWithdraw(address owner)
    ///
    /// This may depend on:
    /// - The owner's share balance.
    /// - Current vault liquidity.
    /// - Withdrawal limits or cooldowns.
    ///
    /// # Panics / Fails
    /// - The `max_withdraw_amount` method must never panic.
    ///   It should return the maximum amount of assets that can be withdrawn by the given account,
    ///   or `0` if withdrawals are not currently allowed.
    ///
    /// Implementations should return `0` if redemptions are currently disabled for the owner.
    fn max_withdraw_amount(&self, owner_id: AccountId) -> U128;

    // ----------------------------
    // Redemption Operations
    // ----------------------------

    /// Redeems `shares` from the caller in exchange for the equivalent amount of underlying assets.
    ///
    /// ERC4626 original function name: redeem(uint256 shares, address receiver, address owner)
    ///
    /// - If `receiver_id` is `None`, defaults to sending assets to the caller.
    /// - Burns the caller's shares.
    /// - Returns the exact amount of assets redeemed.
    ///
    /// # Slippage
    /// - To forcefully redeem shares without accounting for slippage, the user should set `min_amount_out` to `0`.
    /// - To protect against slippage, the user should specify a reasonable `min_amount_out`.
    ///
    /// # Panics / Fails
    /// - If the caller's share balance is insufficient.
    /// - If withdrawal limits prevent the redemption.
    ///
    /// See also: [`Self::preview_redeem_amount`].
    fn redeem(&mut self, shares: U128, min_amount_out: U128, receiver_id: Option<AccountId>) -> PromiseOrValue<U128>;

    /// Simulates redeeming `shares` into assets without executing the redemption.
    ///
    /// ERC4626 original function name: previewRedeem(uint256 shares)
    ///
    /// Differs from [`Self::convert_to_asset_amount`] by factoring in:
    /// - The caller's current share balance.
    /// - Vault withdrawal limits.
    /// - Applicable fees or penalties.
    ///
    /// # Panics / Fails
    /// - The `preview_redeem_amount` method must never panic.
    ///   It should return the amount of assets that would be received for redeeming the given shares,
    ///   or `0` if redemption is not currently allowed.
    ///
    /// Useful for frontends to estimate redemption outcomes.
    fn preview_redeem_amount(&self, shares: U128) -> U128;

    /// Withdraws exactly `assets` worth of underlying tokens from the vault.
    ///
    /// ERC4626 original function name: withdraw(uint256 assets, address receiver, address owner)
    ///
    /// - If `receiver_id` is `None`, defaults to sending assets to the caller.
    /// - Burns the required number of shares to fulfill the withdrawal.
    ///
    /// # Slippage
    /// - To forcefully withdraw assets without accounting for slippage, the user can omit the `max_shares_deducted` parameter.
    /// - To protect against slippage, the user may specify a `max_shares_deducted` parameter.
    ///
    /// # Panics / Fails
    /// - If the caller's share balance cannot cover the withdrawal.
    /// - If withdrawal limits or fees prevent the withdrawal.
    ///
    /// # Events
    /// - The vault **must** emit a `VaultWithdraw` event upon a successful withdrawal.
    /// - Since transactions on NEAR are non-atomic, the vault contract should follow one of these approaches:
    ///   1. Emit a `VaultWithdraw` event when the fee is deducted, and if the withdrawal later fails, emit a `VaultDeposit` event
    ///      to revert the funds; **or**
    ///   2. Emit a `VaultWithdraw` event **only** if the withdrawal succeeds.
    /// - In the reference implementation, the contract emits an `FtBurn` event when the user calls the `withdraw` method.
    ///   If the withdrawal is successful, a `VaultWithdraw` event is emitted in the `resolve_withdraw` callback.
    ///   If the withdrawal fails, an `FtMint` event is emitted instead to restore the user’s balance.
    ///
    /// See also: [`Self::preview_shares_deducted_for_withdraw`].
    fn withdraw(&mut self, asset_amount: U128, max_shares_deducted: Option<U128> ,receiver_id: Option<AccountId>) -> PromiseOrValue<U128>;

    /// Simulates withdrawing exactly `assets` worth of tokens without executing.
    ///
    /// ERC4626 original function name: previewWithdraw(uint256 assets)
    ///
    /// Differs from [`Self::convert_to_shares`] by factoring in:
    /// - The caller's current share balance.
    /// - Vault withdrawal limits.
    /// - Applicable fees or penalties.
    ///
    /// # Panics / Fails
    /// - The `preview_shares_deducted_for_withdraw` method must never panic.
    ///   It should return the number of shares required to withdraw the given amount of assets,
    ///   or `0` if withdrawals are not currently allowed.
    ///
    /// Useful for frontends to preview required shares for a given withdrawal.
    fn preview_shares_deducted_for_withdraw(&self, asset_amount: U128) -> U128;
}
```

### Deposit and Mint

```rust
pub trait FungibleTokenReceiver {
    /// # Events
    /// - The vault **must** emit a `VaultDeposit` event upon a successful deposit.
    /// - The vault should also emit a `FtMint` event for the share they issued.
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> PromiseOrValue<U128>;
}
```

-   According to the NEP-141 standard, all fungible token transfers to a contract must invoke the `ft_on_transfer` callback.
-   In the context of ERC-4626, both the **`deposit`** and **`mint`** functions are implemented through this entrypoint on the vault contract.
-   While NEP-141 does not prescribe how the `msg` parameter should be structured, our suggested convention is to pass a JSON-encoded message with the following schema:

```rust
pub struct DepositMessage {
    /// The minimum number of shares that must be received for this deposit to succeed. (Slippage control)
    min_shares: Option<U128>,
    /// The maximum number of shares that can be minted, used for `mint` operations.
    max_shares: Option<U128>,
    /// The account that should receive the minted shares.
    receiver_id: Option<AccountId>,
    /// Optional memo for logging or off-chain indexing.
    memo: Option<String>,
    /// If `true`, the transfer is treated as a donation and no shares are minted.
    donate: Option<bool>,
}
```

-   Implementers are free to define their own schema for `msg`, but the vault must correctly handle `ft_on_transfer` according to NEP-141:
-   Return `PromiseOrValue::Value(0)` if all tokens were accepted.
-   Return a non-zero `U128` to indicate the number of tokens to refund.

### Events

```rust
/// Event emitted when a deposit is received by the vault.
///
/// This follows the proposed NEP vault standard, referencing the ERC-4626 pattern.
/// Upon receiving assets, the vault mints and issues shares to the `owner_id`.
pub struct VaultDeposit {
    /// The account that sends the deposit (payer of the assets).
    pub sender_id: AccountId,

    /// The account that receives the minted shares.
    pub owner_id: AccountId,

    /// Amount of underlying assets deposited into the vault.
    pub asset_amount: U128,

    /// Amount of shares minted and issued to `owner_id`.
    pub shares: U128,

    /// Optional memo provided by the sender for off-chain use.
    pub memo: Option<String>,
}

/// Event emitted when shares are redeemed from the vault.
///
/// Upon redemption, the vault burns the shares from `owner_id`
/// and transfers the equivalent assets to `receiver_id`.
pub struct VaultWithdraw {
    /// The account that owns the shares being redeemed (burned).
    pub owner_id: AccountId,

    /// The account receiving the underlying assets.
    pub receiver_id: AccountId,

    /// Amount of shares redeemed (burned from the vault).
    pub shares: U128,

    /// Amount of underlying assets withdrawn from the vault.
    pub asset_amount: U128,

    /// Optional memo provided by the redeemer for off-chain use.
    pub memo: Option<String>,
}
```

## Reference Implementation

[Example implementation](https://github.com/Meteor-Wallet/tokenized-vault-nep-implementation).

## Security Implications

### Exchange Rate Manipulation

Vaults allow dynamic exchange rates between shares and assets, calculated by dividing total vault assets by total issued shares. If the vault has a permissionless donation mechanism, it creates vulnerability to inflation attacks where attackers manipulate the rate by donating assets to inflate share values, potentially stealing funds from subsequent depositors. Vault deployers can protect against this attack by making an initial deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Vaults can also implement a virtual decimal offset for issued shares, making inflation attacks significantly less feasible, this is demonstrated in the reference implementation.

### Cross-contract Calls

Redeem and withdraw functions perform cross-contract calls to transfer fungible tokens, creating opportunities for reentrancy attacks and state manipulation during asynchronous execution. Vaults should implement reentrancy protection through proper state management, proper callback security, and rollback mechanisms for failed operations.

### Rounding Direction Security

Vault calculations must consistently round in favor of the vault to prevent exploitation. When issuing shares for deposits or transferring assets for redemptions, round down; when calculating required shares or assets for specific amounts, round up. This asymmetric rounding prevents users from extracting value through repeated micro-transactions that exploit rounding errors and protects existing shareholders from value dilution.

### Oracle and External Price Dependencies

Vaults that rely on external price oracles or cross-contract calls for exchange rate updates face additional security risks in Near's asynchronous environment. Oracle updates create temporal windows where vaults operate with stale pricing data, potentially allowing exploitation. Implementations should include staleness checks, prevent operations during oracle updates, implement proper callback security, and consider fallback pricing mechanisms for oracle failures.

## Alternatives

1. **Custom Per-Protocol Vault Implementations**
    - While possible, this leads to fragmentation, increases integration costs, and reduces composability between protocols.
2. **Direct ERC-4626 clone Without NEAR Adjustments**
    - Rejected because NEAR’s asynchronous execution model makes a one-to-one ERC-4626 clone inefficient. This proposal integrates share and vault logic in a single contract to avoid unnecessary cross-contract calls. Key Differences from ERC-4626 includes:
        - **Deposit & Mint**:
          Unlike ERC-4626, deposits and mints on NEAR must be handled through the
          `ft_on_transfer` callback (as defined by NEP-141), rather than direct method calls.
        - **Async Execution**:
          Since NEAR contracts execute asynchronously, results from `preview*` and `max*`
          view methods cannot be guaranteed to match the actual values during transaction
          execution. Cross-contract calls may be processed in later blocks, leading to
          differences between simulated values and actual outcomes.

## Future possibilities

### NEP-245 Multi Token Support

Future vault implementations could extend this standard to support NEP-245 Multi Token contracts as underlying asset. We have also created a [minimal implementation](https://github.com/Meteor-Wallet/tokenized-vault-mt-nep-implementation).

### Multi-Asset Vault Extensions

Future extensions could allow vaults to accept multiple assets for deposit and withdrawal. This would enable the standardization of LP vaults.

### Asynchronous Vault Operations

Future vault standards could introduce asynchronous deposit and withdrawal patterns through `request_deposit` and `request_withdraw` functions. This would enable integration with cross-chain protocols and real-world asset protocols.

## Consequences

### Positive

-   Enables a unified, predictable vault interface.

-   Simplifies integration for wallets, DEXs, and aggregators.

-   Improves security through consistent design and accounting.

-   Encourages reuse of tooling, libraries, and audits.

### Neutral

-   Standard defines interface, not yield strategy — implementation remains flexible.

-   Protocols may implement only relevant parts of the interface initially.

### Negative

-   Migration overhead for existing vault implementations to become compliant.

### Backwards Compatibility

-   No breaking changes to NEP-141 itself, but existing vault-like contracts that don’t conform will need to add or rename methods to comply.

-   Share tokens must be NEP-141 compliant, meaning non-NEP-141 share implementations require migration.

## Changelog

### 1.0.0 - Initial Version

> Placeholder for the context about when and who approved this NEP version.

#### Benefits

> List of benefits filled by the Subject Matter Experts while reviewing this version:

-   Would benefit the ecosystem by introducing a standardized way to create token vaults. Indeed, multiple projects currently exists (e.g. metapool, more markets, etc) but none of them follow a single standard making it hard to interconnect with them
-   Benefit 2

#### Concerns

No major concerns were raised, besides the need to need to be careful with the #security implications sections described above

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).

```

```
