<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>NEAR Protocol Specification</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Specification of the NEAR Protocol">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="README.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="expanded "><a href="Terminology.html"><strong aria-hidden="true">2.</strong> Terminology</a></li><li class="expanded "><a href="DataStructures/README.html"><strong aria-hidden="true">3.</strong> Data Structures</a></li><li><ol class="section"><li class="expanded "><a href="DataStructures/Account.html"><strong aria-hidden="true">3.1.</strong> Account</a></li><li class="expanded "><a href="DataStructures/AccessKey.html"><strong aria-hidden="true">3.2.</strong> Access Key</a></li><li class="expanded "><a href="DataStructures/Transaction.html"><strong aria-hidden="true">3.3.</strong> Transaction</a></li></ol></li><li class="expanded "><a href="Architecture.html"><strong aria-hidden="true">4.</strong> Architecture</a></li><li class="expanded "><a href="ChainSpec/README.html"><strong aria-hidden="true">5.</strong> Chain specification</a></li><li><ol class="section"><li class="expanded "><a href="ChainSpec/Transactions.html"><strong aria-hidden="true">5.1.</strong> Transactions</a></li></ol></li><li class="expanded "><a href="RuntimeSpec/README.html"><strong aria-hidden="true">6.</strong> Runtime specification</a></li><li><ol class="section"><li class="expanded "><a href="RuntimeSpec/FunctionCall.html"><strong aria-hidden="true">6.1.</strong> FunctionCall</a></li><li class="expanded "><a href="RuntimeSpec/Transactions.html"><strong aria-hidden="true">6.2.</strong> Transactions</a></li><li class="expanded "><a href="RuntimeSpec/Actions.html"><strong aria-hidden="true">6.3.</strong> Actions</a></li><li class="expanded "><a href="RuntimeSpec/Receipts.html"><strong aria-hidden="true">6.4.</strong> Receipts</a></li><li class="expanded "><a href="RuntimeSpec/Scenarios/Scenarios.html"><strong aria-hidden="true">6.5.</strong> Scenarios</a></li><li><ol class="section"><li class="expanded "><a href="RuntimeSpec/Scenarios/FinancialTransaction.html"><strong aria-hidden="true">6.5.1.</strong> Financial Transaction</a></li><li class="expanded "><a href="RuntimeSpec/Scenarios/CrossContractCall.html"><strong aria-hidden="true">6.5.2.</strong> Cross-Contract Call</a></li></ol></li><li class="expanded "><a href="RuntimeSpec/Components/Components.html"><strong aria-hidden="true">6.6.</strong> Components</a></li><li><ol class="section"><li class="expanded "><a href="RuntimeSpec/Components/RuntimeCrate.html"><strong aria-hidden="true">6.6.1.</strong> Runtime crate</a></li><li class="expanded "><a href="RuntimeSpec/Components/BindingsSpec/BindingsSpec.html"><strong aria-hidden="true">6.6.2.</strong> Bindings Specification</a></li><li><ol class="section"><li class="expanded "><a href="RuntimeSpec/Components/BindingsSpec/RegistersAPI.html"><strong aria-hidden="true">6.6.2.1.</strong> Registers API</a></li><li class="expanded "><a href="RuntimeSpec/Components/BindingsSpec/TrieAPI.html"><strong aria-hidden="true">6.6.2.2.</strong> Trie API</a></li><li class="expanded "><a href="RuntimeSpec/Components/BindingsSpec/PromisesAPI.html"><strong aria-hidden="true">6.6.2.3.</strong> Promises API</a></li><li class="expanded "><a href="RuntimeSpec/Components/BindingsSpec/ContextAPI.html"><strong aria-hidden="true">6.6.2.4.</strong> Context API</a></li><li class="expanded "><a href="RuntimeSpec/Components/BindingsSpec/EconomicsAPI.html"><strong aria-hidden="true">6.6.2.5.</strong> Economics API</a></li><li class="expanded "><a href="RuntimeSpec/Components/BindingsSpec/MathAPI.html"><strong aria-hidden="true">6.6.2.6.</strong> Math API</a></li><li class="expanded "><a href="RuntimeSpec/Components/BindingsSpec/MiscellaneousAPI.html"><strong aria-hidden="true">6.6.2.7.</strong> Miscellaneous API</a></li></ol></li></ol></li></ol></li><li class="expanded "><a href="GenesisConfig/GenesisConfig.html"><strong aria-hidden="true">7.</strong> GenesisConfig</a></li><li><ol class="section"><li class="expanded "><a href="GenesisConfig/RuntimeConfig.html"><strong aria-hidden="true">7.1.</strong> RuntimeConfig</a></li><li><ol class="section"><li class="expanded "><a href="GenesisConfig/RuntimeFeeConfig.html"><strong aria-hidden="true">7.1.1.</strong> RuntimeFeeConfig</a></li><li><ol class="section"><li class="expanded "><a href="GenesisConfig/RuntimeFeeConfig/AccessKeyCreationConfig.html"><strong aria-hidden="true">7.1.1.1.</strong> AccessKeyCreationConfig</a></li><li class="expanded "><a href="GenesisConfig/RuntimeFeeConfig/ActionCreationConfig.html"><strong aria-hidden="true">7.1.1.2.</strong> ActionCreationConfig</a></li><li class="expanded "><a href="GenesisConfig/RuntimeFeeConfig/DataReceiptCreationConfig.html"><strong aria-hidden="true">7.1.1.3.</strong> DataReceiptCreationConfig</a></li><li class="expanded "><a href="GenesisConfig/RuntimeFeeConfig/StorageUsageConfig.html"><strong aria-hidden="true">7.1.1.4.</strong> StorageUsageConfig</a></li><li class="expanded "><a href="GenesisConfig/RuntimeFeeConfig/Fee.html"><strong aria-hidden="true">7.1.1.5.</strong> Fee</a></li><li class="expanded "><a href="GenesisConfig/RuntimeFeeConfig/Fraction.html"><strong aria-hidden="true">7.1.1.6.</strong> Fraction</a></li></ol></li><li class="expanded "><a href="GenesisConfig/VMConfig.html"><strong aria-hidden="true">7.1.2.</strong> VMConfig</a></li><li><ol class="section"><li class="expanded "><a href="GenesisConfig/ExtCostsConfig.html"><strong aria-hidden="true">7.1.2.1.</strong> ExtCostsConfig</a></li></ol></li></ol></li></ol></li><li class="expanded "><a href="Economics/README.html"><strong aria-hidden="true">8.</strong> Economics</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">NEAR Protocol Specification</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-near-protocol-specification" id="the-near-protocol-specification">The NEAR Protocol Specification</a></h1>
<p>Near Protocol is the scalable blockchain protocol.</p>
<p>For the overview of the NEAR Protocol, read the following documents in numerical order.</p>
<ol>
<li><a href="Terminology.html">Terminology</a></li>
<li><a href="DataStructures/README.html">Data structures</a></li>
<li><a href="Architecture.html">Architecture</a></li>
<li><a href="ChainSpec/README.html">Chain specification</a></li>
<li><a href="RuntimeSpec/README.html">Runtime specification</a></li>
<li><a href="Economics/README.html">Economics</a></li>
</ol>
<h1><a class="header" href="#terminology" id="terminology">Terminology</a></h1>
<h2><a class="header" href="#abstraction-definitions" id="abstraction-definitions">Abstraction definitions</a></h2>
<h3><a class="header" href="#chain" id="chain">Chain</a></h3>
<p>A <em>chain</em> is a replication machinery, that provides for any type of state a way to replicate across the network and reach consensus on the state.</p>
<h1><a class="header" href="#primitives" id="primitives">Primitives</a></h1>
<ul>
<li><a href="DataStructures/Account.html">Account</a>
<ul>
<li><a href="DataStructures/Account.html#account-id">Account ID</a></li>
<li><a href="DataStructures/Account.html#account">Account</a></li>
</ul>
</li>
<li><a href="DataStructures/AccessKey.html">Access Keys</a></li>
<li><a href="DataStructures/Transaction.html">Transaction</a></li>
</ul>
<h1><a class="header" href="#accounts" id="accounts">Accounts</a></h1>
<h2><a class="header" href="#account-id" id="account-id">Account ID</a></h2>
<p>NEAR Protocol has an account names system. Account ID is similar to a username. Account IDs have to follow the rules.</p>
<h3><a class="header" href="#account-id-rules" id="account-id-rules">Account ID Rules</a></h3>
<ul>
<li>minimum length is 2</li>
<li>maximum length is 64</li>
<li><strong>Account ID</strong> consists of <strong>Account ID parts</strong> separated by <code>.</code></li>
<li><strong>Account ID part</strong> consists of lowercase alphanumeric symbols separated by either <code>_</code> or <code>-</code>.</li>
</ul>
<p>Account names are similar to a domain names.
Anyone can create a top level account (TLA) without separators, e.g. <code>near</code>.
Only <code>near</code> can create <code>alice.near</code>. And only <code>alice.near</code> can create <code>app.alice.near</code> and so on.
Note, <code>near</code> can NOT create <code>app.alice.near</code> directly.</p>
<p>Regex for a full account ID, without checking for length:</p>
<pre><code class="language-regex">^(([a-z\d]+[\-_])*[a-z\d]+\.)*([a-z\d]+[\-_])*[a-z\d]+$
</code></pre>
<p>There is a rent for the account ID length in case it's less than 11 characters long. See [Economics] for the details.</p>
<h3><a class="header" href="#examples" id="examples">Examples</a></h3>
<p>Valid accounts:</p>
<pre><code>ok
bowen
ek-2
ek.near
com
google.com
bowen.google.com
near
illia.cheap-accounts.near
max_99.near
100
near2019
over.9000
a.bro
// Valid, but can't be created, because &quot;a&quot; is too short
bro.a
</code></pre>
<p>Invalid accounts:</p>
<pre><code>not ok           // Whitespace characters are not allowed
a                // Too short
100-             // Suffix separator
bo__wen          // Two separators in a row
_illia           // Prefix separator
.near            // Prefix dot separator
near.            // Suffix dot separator
a..near          // Two dot separators in a row
$$$              // Non alphanumeric characters are not allowed
WAT              // Non lowercase characters are not allowed
me@google.com    // @ is not allowed (it was allowed in the past)
// TOO LONG:
abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz
</code></pre>
<h2><a class="header" href="#account" id="account">Account</a></h2>
<p>Data for an single account is collocated in one shard. The account data consists of the following:</p>
<ul>
<li>Balance</li>
<li>Locked balance (for staking)</li>
<li>Code of the contract</li>
<li>Key-value storage of the contract. Stored in a ordered trie</li>
<li><a href="DataStructures/AccessKey.html">Access Keys</a></li>
<li><a href="DataStructures/../Runtime/Receipts.html#postponed-actionreceipt">Postponed ActionReceipts</a></li>
<li><a href="DataStructures/../Runtime/Receipts.html#received-datareceipt">Received DataReceipts</a></li>
</ul>
<h4><a class="header" href="#balances" id="balances">Balances</a></h4>
<p>Total account balance consists of unlocked balance and locked balance.</p>
<p>Unlocked balance is tokens that the account can use for transaction fees, transfers staking and other operations.</p>
<p>Locked balance is the tokens that are currently in use for staking to be a validator or to become a validator.
Locked balance may become unlocked at the beginning of an epoch. See [Staking] for details.</p>
<h4><a class="header" href="#contracts" id="contracts">Contracts</a></h4>
<p>A contract (AKA smart contract) is a program in WebAssembly that belongs to a specific account.
When account is created, it doesn't have a contract.
A contract has to be explicitly deployed, either by the account owner, or during the account creation.
A contract can be executed by anyone who calls a method on your account. A contract has access to the storage on your account.</p>
<h4><a class="header" href="#storage" id="storage">Storage</a></h4>
<p>Every account has its own storage. It's a persistent key-value trie. Keys are ordered in lexicographical order.
The storage can only be modified by the contract on the account.
Current implementation on Runtime only allows your account's contract to read from the storage, but this might change in the future and other accounts's contracts will be able to read from your storage.</p>
<p>NOTE: Accounts are charged recurrent rent for the total storage. This includes storage of the account itself, contract code, contract storage and all access keys.</p>
<h4><a class="header" href="#access-keys" id="access-keys">Access Keys</a></h4>
<p>An access key grants an access to a account. Each access key on the account is identified by a unique public key.
This public key is used to validate signature of transactions.
Each access key contains a unique nonce to differentiate or order transactions signed with this access key.</p>
<p>An access keys have a permission associated with it. The permission can be one of two types:</p>
<ul>
<li>Full permission. It grants full access to the account.</li>
<li>Function call permission. It grants access to only issue function call transactions.</li>
</ul>
<p>See [Access Keys] for more details.</p>
<h1><a class="header" href="#access-keys-1" id="access-keys-1">Access Keys</a></h1>
<p>Access key provides an access for a particular account. Each access key belongs to some account and
is identified by a unique (within the account) public key. Access keys are stored as <code>account_id,public_key</code> in a trie state. Account can have from <a href="DataStructures/AccessKey.html#account-without-access-keys">zero</a> to multiple access keys.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct AccessKey {
    /// The nonce for this access key.
    /// NOTE: In some cases the access key needs to be recreated. If the new access key reuses the
    /// same public key, the nonce of the new access key should be equal to the nonce of the old
    /// access key. It's required to avoid replaying old transactions again.
    pub nonce: Nonce,
    /// Defines permissions for this access key.
    pub permission: AccessKeyPermission,
}
<span class="boring">}
</span></code></pre></pre>
<p>There are 2 types of <code>AccessKeyPermission</code> in Near currently: <code>FullAccess</code> and <code>FunctionCall</code>. <code>FunctionCall</code> grants a permission to issue any action on account like <a href="DataStructures/Transaction#DeployContract">DeployContract</a>, <a href="DataStructures/Transaction#Transfer">Transfer</a> tokens to other account, call functions <a href="DataStructures/Transaction#FunctionCall">FunctionCall</a>, <a href="DataStructures/Transaction#Stake">Stake</a> and even delete account <a href="DataStructures/Transaction#DeleteAccountAction">DeleteAccountAction</a>. <code>FullAccess</code> also allow to manage access keys. <code>AccessKeyPermission::FunctionCall</code> limits to do only contract calls.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub enum AccessKeyPermission {
    FunctionCall(FunctionCallPermission),
    FullAccess,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#accesskeypermissionfunctioncall" id="accesskeypermissionfunctioncall">AccessKeyPermission::FunctionCall</a></h2>
<p>Grants limited permission to make <a href="DataStructures/Transaction#FunctionCall">FunctionCall</a> to a specified <code>receiver_id</code> and methods of a particular contract with a limit of allowed balance to spend.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct FunctionCallPermission {
    /// Allowance is a balance limit to use by this access key to pay for function call gas and
    /// transaction fees. When this access key is used, both account balance and the allowance is
    /// decreased by the same value.
    /// `None` means unlimited allowance.
    /// NOTE: To change or increase the allowance, the old access key needs to be deleted and a new
    /// access key should be created.
    pub allowance: Option&lt;Balance&gt;,

    /// The access key only allows transactions with the given receiver's account id.
    pub receiver_id: AccountId,

    /// A list of method names that can be used. The access key only allows transactions with the
    /// function call of one of the given method names.
    /// Empty list means any method name can be used.
    pub method_names: Vec&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#account-without-access-keys" id="account-without-access-keys">Account without access keys</a></h2>
<p>If account has no access keys attached it means that it has no owner who can run transactions from its behalf. However, if such accounts has code it can be invoked by other accounts and contracts.</p>
<h1><a class="header" href="#transaction" id="transaction">Transaction</a></h1>
<h1><a class="header" href="#architecture" id="architecture">Architecture</a></h1>
<p>Near node consists roughly of a blockchain layer and a runtime layer.
These layers are designed to be independent from each other: the blockchain layer can in theory support runtime that processes
transactions differently, has a different virtual machine (e.g. RISC-V), has different fees; on the other hand the runtime
is oblivious to where the transactions are coming from. It is not aware whether the
blockchain it runs on is sharded, what consensus it uses, and whether it runs as part of a blockchain at all.</p>
<p>The blockchain layer and the runtime layer share the following components and invariants:</p>
<h2><a class="header" href="#transactions-and-receipts" id="transactions-and-receipts">Transactions and Receipts</a></h2>
<p>Transactions and receipts are a fundamental concept in Near Protocol. Transactions represent actions requested by the
blockchain user, e.g. send assets, create account, execute a method, etc. Receipts, on the other hand is an internal
structure; think of a receipt as a message which is used inside a message-passing system.</p>
<p>Transactions are created outside the Near Protocol node, by the user who sends them via RPC or network communication.
Receipts are created by the runtime from transactions or as the result of processing other receipts.</p>
<p>Blockchain layer cannot create or process transactions and receipts, it can only manipulate them by passing them
around and feeding them to a runtime.</p>
<h2><a class="header" href="#account-based-system" id="account-based-system">Account-Based System</a></h2>
<p>Similar to Ethereum, Near Protocol is an account-based system. Which means that each blockchain user is roughly
associated with one or several accounts (there are exceptions though, when users share an account and are separated
through the access keys).</p>
<p>The runtime is essentially a complex set of rules on what to do with accounts based on the information from the
transactions and the receipts. It is therefore deeply aware of the concept of account.</p>
<p>Blockchain layer however is mostly aware of the accounts through the trie (see below) and the validators (see below).
Outside these two it does not operate on the accounts directly.</p>
<h3><a class="header" href="#assume-every-account-belongs-to-its-own-shard" id="assume-every-account-belongs-to-its-own-shard">Assume every account belongs to its own shard</a></h3>
<p>Every account at NEAR belongs to some shard.
All the information related to this account also belongs to the same shard. The information includes:</p>
<ul>
<li>Balance</li>
<li>Locked balance (for staking)</li>
<li>Code of the contract</li>
<li>Key-value storage of the contract</li>
<li>All Access Keys</li>
</ul>
<p>Runtime assumes, it's the only information that is available for the contract execution.
While other accounts may belong to the same shards, the Runtime never uses or provides them during contract execution.
We can just assume that every account belongs to its own shard. So there is no reason to intentionally try to collocate accounts.</p>
<h2><a class="header" href="#trie" id="trie">Trie</a></h2>
<p>Near Protocol is a stateful blockchain -- there is a state associated with each account and the user actions performed
through transactions mutate that state. The state then is stored as a trie, and both the blockchain layer and the
runtime layer are aware of this technical detail.</p>
<p>The blockchain layer manipulates the trie directly. It partitions the trie between the shards to distribute the load.
It synchronizes the trie between the nodes, and eventually it is responsible for maintaining the consistency of the trie
between the nodes through its consensus mechanism and other game-theoretic methods.</p>
<p>The runtime layer is also aware that the storage that it uses to perform the operations on is a trie. In general it does
not have to know this technical detail and in theory we could have abstracted out the trie as a generic key-value storage.
However, we allow some trie-specific operations that we expose to the smart contract developers so that they utilize
Near Protocol to its maximum efficiency.</p>
<h2><a class="header" href="#tokens-and-gas" id="tokens-and-gas">Tokens and gas</a></h2>
<p>Even though tokens is a fundamental concept of the blockchain, it is neatly encapsulated
inside the runtime layer together with the gas, fees, and rewards.</p>
<p>The only way the blockchain layer is aware of the tokens and the gas is through the computation of the exchange rate
and the inflation which is based strictly on the block production mechanics.</p>
<h2><a class="header" href="#validators" id="validators">Validators</a></h2>
<p>Both the blockchain layer and the runtime layer are aware of a special group of participants who are
responsible for maintaining the integrity of the Near Protocol. These participants are associated with the
accounts and are rewarded accordingly. The reward part is what the runtime layer is aware of, while everything
around the orchestration of the validators is inside the blockchain layer.</p>
<h2><a class="header" href="#blockchain-layer-concepts" id="blockchain-layer-concepts">Blockchain Layer Concepts</a></h2>
<p>Interestingly, the following concepts are for the blockchain layer only and the runtime layer is not aware of them:</p>
<ul>
<li>Sharding -- the runtime layer does not know that it is being used in a sharded blockchain, e.g. it does not know
that the trie it works on is only a part of the overall blockchain state;</li>
<li>Blocks or chunks -- the runtime does not know that the receipts that it processes constitute a chunk and that the output
receipts will be used in other chunks. From the runtime perspective it consumes and outputs batches of transactions and receipts;</li>
<li>Consensus -- the runtime does not know how consistency of the state is maintained;</li>
<li>Communication -- the runtime don't know anything about the current network topology. Receipt has only a receiver_id (a recipient account), but knows nothing about the destination shard, so it's a responsibility of a blockchain layer to route a particular receipt.</li>
</ul>
<h2><a class="header" href="#runtime-layer-concepts" id="runtime-layer-concepts">Runtime Layer Concepts</a></h2>
<ul>
<li>Fees and rewards -- fees and rewards are neatly encapsulated in the runtime layer. The blockchain layer, however
has an indirect knowledge of them through the computation of the tokens-to-gas exchange rate and the inflation.</li>
</ul>
<h1><a class="header" href="#chain-specification" id="chain-specification">Chain Specification</a></h1>
<p>TBD</p>
<h1><a class="header" href="#transactions-in-the-blockchain-layer" id="transactions-in-the-blockchain-layer">Transactions in the Blockchain Layer</a></h1>
<p>A client creates a transaction, computes the transaction hash and signs this hash to get a signed transaction.
Now this signed transaction can be sent to a node.</p>
<p>When a node receives a new signed transaction, it validates the transaction (if the node tracks the shard) and gossips it to the peers. Eventually, the valid transaction is added to a transaction pool.</p>
<p>Every validating node has its own transaction pool. The transaction pool maintains transactions that were not yet discarded and not yet included into the chain.</p>
<p>Before producing a chunk transactions are ordered and validated again. This is done to produce chunks with only valid transactions.</p>
<h2><a class="header" href="#transaction-ordering" id="transaction-ordering">Transaction ordering</a></h2>
<p>The transaction pool groups transactions by a pair of <code>(signer_id, signer_public_key)</code>.
The <code>signer_id</code> is the account ID of the user who signed the transaction, the <code>signer_public_key</code> is the public key of the account's access key that was used to sign the transactions.
Transactions within a group are not ordered.</p>
<p>The valid order of the transactions in a chunk is the following:</p>
<ul>
<li>transactions are ordered in batches.</li>
<li>within a batch all transactions keys should have different.</li>
<li>a set of transaction keys in each subsequent batch should be a sub-set of keys from the previous batch.</li>
<li>transactions with the same key should be ordered in strictly increasing order of their corresponding nonces.</li>
</ul>
<p>Note:</p>
<ul>
<li>the order within a batch is undefined. Each node should use a unique secret seed for that ordering to users from finding the lowest keys to get advantage of every node.</li>
</ul>
<p>Transaction pool provides a draining structure that allows to pull transactions in a proper order.</p>
<h2><a class="header" href="#transaction-validation" id="transaction-validation">Transaction validation</a></h2>
<p>The transaction validation happens twice, once before adding to the transaction pool, next before adding to a chunk.</p>
<h3><a class="header" href="#before-adding-to-a-transaction-pool" id="before-adding-to-a-transaction-pool">Before adding to a transaction pool</a></h3>
<p>This is done to quickly filter out transactions that have an invalid signature or are invalid on the latest state.</p>
<h3><a class="header" href="#before-adding-to-a-chunk" id="before-adding-to-a-chunk">Before adding to a chunk</a></h3>
<p>A chunk producer has to create a chunk with valid and ordered transactions up to some limits.
One limit is the maximum number of transactions, another is the total gas burnt for transactions.</p>
<p>To order and filter transactions, chunk producer gets a pool iterator and passes it to the runtime adapter.
The runtime adapter pulls transactions one by one.
The valid transactions are added to the result, invalid transactions are discarded.
Once the limit is reached, all the remaining transactions from the iterator are returned back to the pool.</p>
<h2><a class="header" href="#pool-iterator" id="pool-iterator">Pool iterator</a></h2>
<p>Pool Iterator is a trait that iterates over transaction groups until all transaction group are empty.
Pool Iterator returns a mutable reference to a transaction group that implements a draining iterator.
The draining iterator is like a normal iterator, but it removes the returned entity from the group.
It pulls transactions from the group in order from the smallest nonce to largest.</p>
<p>The pool iterator and draining iterators for transaction groups allow the runtime adapter to create proper order.
For every transaction group, the runtime adapter keeps pulling transactions until the valid transaction is found.
If the transaction group becomes empty, then it's skipped.</p>
<p>The runtime adapter may implement the following code to pull all valid transactions:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut valid_transactions = vec![];
let mut pool_iter = pool.pool_iterator();
while let Some(group_iter) = pool_iter.next() {
    while let Some(tx) = group_iter.next() {
        if is_valid(tx) {
            valid_transactions.push(tx);
            break;
        }
    }
}
valid_transactions
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#transaction-ordering-example-using-pool-iterator" id="transaction-ordering-example-using-pool-iterator">Transaction ordering example using pool iterator.</a></h3>
<p>Let's say:</p>
<ul>
<li>account IDs as uppercase letters (<code>&quot;A&quot;</code>, <code>&quot;B&quot;</code>, <code>&quot;C&quot;</code> ...)</li>
<li>public keys are lowercase letters (<code>&quot;a&quot;</code>, <code>&quot;b&quot;</code>, <code>&quot;c&quot;</code> ...)</li>
<li>nonces are numbers (<code>1</code>, <code>2</code>, <code>3</code> ...)</li>
</ul>
<p>A pool might have group of transactions in the hashmap:</p>
<pre><code>transactions: {
  (&quot;A&quot;, &quot;a&quot;) -&gt; [1, 3, 2, 1, 2]
  (&quot;B&quot;, &quot;b&quot;) -&gt; [13, 14]
  (&quot;C&quot;, &quot;d&quot;) -&gt; [7]
  (&quot;A&quot;, &quot;c&quot;) -&gt; [5, 2, 3]
}
</code></pre>
<p>There are 3 accounts (<code>&quot;A&quot;</code>, <code>&quot;B&quot;</code>, <code>&quot;C&quot;</code>). Account <code>&quot;A&quot;</code> used 2 public keys (<code>&quot;a&quot;</code>, <code>&quot;c&quot;</code>). Other accounts used 1 public key each.
Transactions within each group may have repeated nonces while in the pool.
That's because the pool doesn't filter transactions with the same nonce, only transactions with the same hash.</p>
<p>For this example, let's say that transactions are valid if the nonce is even and strictly greater than the previous nonce for the same key.</p>
<h5><a class="header" href="#initialization" id="initialization">Initialization</a></h5>
<p>When <code>.pool_iterator()</code> is called, a new <code>PoolIteratorWrapper</code> is created and it holds the mutuable reference to the pool,
so the pool can't be modified outside of this iterator. The wrapper looks like this:</p>
<pre><code>pool: {
    transactions: {
      (&quot;A&quot;, &quot;a&quot;) -&gt; [1, 3, 2, 1, 2]
      (&quot;B&quot;, &quot;b&quot;) -&gt; [13, 14]
      (&quot;C&quot;, &quot;d&quot;) -&gt; [7]
      (&quot;A&quot;, &quot;c&quot;) -&gt; [5, 2, 3]
    }
}
sorted_groups: [],
</code></pre>
<p><code>sorted_groups</code> is a queue of sorted transaction groups that were already sorted and pulled from the pool.</p>
<h5><a class="header" href="#transaction-1" id="transaction-1">Transaction #1</a></h5>
<p>The first group to be selected is for key <code>(&quot;A&quot;, &quot;a&quot;)</code>, the pool iterator sorts transactions by nonces and returns the mutable references to the group. Sorted nonces are:
<code>[1, 1, 2, 2, 3]</code>. Runtime adapter pulls <code>1</code>, then <code>1</code>, and then <code>2</code>. Both transactions with nonce <code>1</code> are invalid because of odd nonce.</p>
<p>Transaction with nonce <code>2</code> is added to the list of valid transactions.</p>
<p>The transaction group is dropped and the pool iterator wrapper becomes the following:</p>
<pre><code>pool: {
    transactions: {
      (&quot;B&quot;, &quot;b&quot;) -&gt; [13, 14]
      (&quot;C&quot;, &quot;d&quot;) -&gt; [7]
      (&quot;A&quot;, &quot;c&quot;) -&gt; [5, 2, 3]
    }
}
sorted_groups: [
  (&quot;A&quot;, &quot;a&quot;) -&gt; [2, 3]
],
</code></pre>
<h5><a class="header" href="#transaction-2" id="transaction-2">Transaction #2</a></h5>
<p>The next group is for key <code>(&quot;B&quot;, &quot;b&quot;)</code>, the pool iterator sorts transactions by nonces and returns the mutable references to the group. Sorted nonces are:
<code>[13, 14]</code>. Runtime adapter pulls <code>13</code>, then <code>14</code>. The transaction with nonce <code>13</code> is invalid because of odd nonce.</p>
<p>Transaction with nonce <code>14</code> is added to the list of valid transactions.</p>
<p>The transaction group is dropped, but it's empty, so the pool iterator drops it completely:</p>
<pre><code>pool: {
    transactions: {
      (&quot;C&quot;, &quot;d&quot;) -&gt; [7]
      (&quot;A&quot;, &quot;c&quot;) -&gt; [5, 2, 3]
    }
}
sorted_groups: [
  (&quot;A&quot;, &quot;a&quot;) -&gt; [2, 3]
],
</code></pre>
<h5><a class="header" href="#transaction-3" id="transaction-3">Transaction #3</a></h5>
<p>The next group is for key <code>(&quot;C&quot;, &quot;d&quot;)</code>, the pool iterator sorts transactions by nonces and returns the mutable references to the group. Sorted nonces are:
<code>[7]</code>. Runtime adapter pulls <code>7</code>. The transaction with nonce <code>7</code> is invalid because of odd nonce.</p>
<p>No valid transactions is added for this group.</p>
<p>The transaction group is dropped, it's empty, so the pool iterator drops it completely:</p>
<pre><code>pool: {
    transactions: {
      (&quot;A&quot;, &quot;c&quot;) -&gt; [5, 2, 3]
    }
}
sorted_groups: [
  (&quot;A&quot;, &quot;a&quot;) -&gt; [2, 3]
],
</code></pre>
<p>The next group is for key <code>(&quot;A&quot;, &quot;c&quot;)</code>, the pool iterator sorts transactions by nonces and returns the mutable references to the group. Sorted nonces are:
<code>[2, 3, 5]</code>. Runtime adapter pulls <code>2</code>.</p>
<p>It's a valid transaction, so it's added to the list of valid transactions.</p>
<p>The transaction group is dropped, so the pool iterator drops it completely:</p>
<pre><code>pool: {
    transactions: { }
}
sorted_groups: [
  (&quot;A&quot;, &quot;a&quot;) -&gt; [2, 3]
  (&quot;A&quot;, &quot;c&quot;) -&gt; [3, 5]
],
</code></pre>
<h5><a class="header" href="#transaction-4" id="transaction-4">Transaction #4</a></h5>
<p>The next group is pulled not from the pool, but from the sorted_groups. The key is <code>(&quot;A&quot;, &quot;a&quot;)</code>.
It's already sorted, so the iterator returns the mutable reference. Nonces are:
<code>[2, 3]</code>. Runtime adapter pulls <code>2</code>, then pulls <code>3</code>.</p>
<p>The transaction with nonce <code>2</code> is invalid, because we've already pulled a transaction #1 from this group and it had nonce <code>2</code>.
The new nonce has to be larger than the previous nonce, so this transaction is invalid.</p>
<p>The transaction with nonce <code>3</code> is invalid because of odd nonce.</p>
<p>No valid transactions is added for this group.</p>
<p>The transaction group is dropped, it's empty, so the pool iterator drops it completely:</p>
<pre><code>pool: {
    transactions: { }
}
sorted_groups: [
  (&quot;A&quot;, &quot;c&quot;) -&gt; [3, 5]
],
</code></pre>
<p>The next group is for key <code>(&quot;A&quot;, &quot;c&quot;)</code>, with nonces <code>[3, 5]</code>.
Runtime adapter pulls <code>3</code>, then pulls <code>5</code>. Both transactions are invalid, because the nonce is odd.</p>
<p>No transactions are added.</p>
<p>The transaction group is dropped, the pool iterator wrapper becomes empty:</p>
<pre><code>pool: {
    transactions: { }
}
sorted_groups: [ ],
</code></pre>
<p>When runtime adapter tries to pull the next group, the pool iterator returns <code>None</code>, so the runtime adapter drops the iterator.</p>
<h5><a class="header" href="#dropping-iterator" id="dropping-iterator">Dropping iterator</a></h5>
<p>If the iterator was not fully drained, but some transactions still remained. They would be reinserted back into the pool.</p>
<h5><a class="header" href="#chunk-transactions" id="chunk-transactions">Chunk Transactions</a></h5>
<p>Transactions that were pulled from the pool:</p>
<pre><code>// First batch
(&quot;A&quot;, &quot;a&quot;, 1),
(&quot;A&quot;, &quot;a&quot;, 1),
(&quot;A&quot;, &quot;a&quot;, 2),
(&quot;B&quot;, &quot;b&quot;, 13),
(&quot;B&quot;, &quot;b&quot;, 14),
(&quot;C&quot;, &quot;d&quot;, 7),
(&quot;A&quot;, &quot;c&quot;, 2),

// Next batch
(&quot;A&quot;, &quot;a&quot;, 2),
(&quot;A&quot;, &quot;a&quot;, 3),
(&quot;A&quot;, &quot;c&quot;, 3),
(&quot;A&quot;, &quot;c&quot;, 5),
</code></pre>
<p>The valid transactions are:</p>
<pre><code>(&quot;A&quot;, &quot;a&quot;, 2),
(&quot;B&quot;, &quot;b&quot;, 14),
(&quot;A&quot;, &quot;c&quot;, 2),
</code></pre>
<p>In total there were only 3 valid transactions, that resulted in one batch.</p>
<h3><a class="header" href="#order-validation" id="order-validation">Order validation</a></h3>
<p>Other validators need to check the order of transactions in the produced chunk.
It can be done in linear time, using a greedy algorithm.</p>
<p>To select a first batch we need to iterate over transactions one by one until we see a transaction
with the key that we've already included in the first batch.
This transaction belongs to the next batch.</p>
<p>Now all transactions in the N+1 batch should have a corresponding transaction with the same key in the N batch.
If there are no transaction with the same key in the N batch, then the order is invalid.</p>
<p>We also enforce the order of the sequence of transactions for the same key, the nonces of them should be in strictly increasing order.</p>
<p>Here is the algorithm that validates the order:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn validate_order(txs: &amp;Vec&lt;Transaction&gt;) -&gt; bool {
    let mut nonces: HashMap&lt;Key, Nonce&gt; = HashMap::new();
    let mut batches: HashMap&lt;Key, usize&gt; = HashMap::new();
    let mut current_batch = 1;

    for tx in txs {
        let key = tx.key();

        // Verifying nonce
        let nonce = tx.nonce();
        if let Some(last_nonce) = nonces.get(key) {
            if nonce &lt;= last_nonce {
                // Nonces should increase.
                return false;
            }
        }
        nonces.insert(key, nonce);

        // Verifying batch
        if let Some(last_batch) = batches.get(key) {
            if last_batch == current_batch {
                current_batch += 1;
            } else if last_batch &lt; current_batch - 1 {
                // Was skipped this key in the previous batch
                return false;
            }
        } else {
            if current_batch &gt; 1 {
                // Not in first batch
                return false;
            }
        }
        batches.insert(key, batch);
    }
    true
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#runtime-specification" id="runtime-specification">Runtime Specification</a></h1>
<h1><a class="header" href="#function-call" id="function-call">Function Call</a></h1>
<p>In this section we provide an explanation how the <code>FunctionCall</code> action execution works, what are the inputs and what are the outputs. Suppose runtime received the following ActionReceipt:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>ActionReceipt {
     id: &quot;A1&quot;,
     signer_id: &quot;alice&quot;,
     signer_public_key: &quot;6934...e248&quot;,
     receiver_id: &quot;dex&quot;,
     predecessor_id: &quot;alice&quot;,
     input_data_ids: [],
     output_data_receivers: [],
     actions: [FunctionCall { gas: 100000, deposit: 100000u128, method_name: &quot;exchange&quot;, args: &quot;{arg1, arg2, ...}&quot;, ... }],
 }
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#input_data_ids-to-promiseresults" id="input_data_ids-to-promiseresults">input_data_ids to PromiseResult's</a></h3>
<p><code>ActionReceipt.input_data_ids</code> must be satisfied before execution (see <a href="RuntimeSpec/FunctionCall.html#receipt-matching">Receipt Matching</a>). Each of <code>ActionReceipt.input_data_ids</code> will be converted to the <code>PromiseResult::Successful(Vec&lt;u8&gt;)</code> if <code>data_id.data</code> is <code>Some(Vec&lt;u8&gt;)</code> otherwise if <code>data_id.data</code> is <code>None</code> promise will be <code>PromiseResult::Failed</code>.</p>
<h2><a class="header" href="#input" id="input">Input</a></h2>
<p>The <code>FunctionCall</code> executes in the <code>receiver_id</code> account environment.</p>
<ul>
<li>a vector of <a href="RuntimeSpec/FunctionCall.html#promise-results">Promise Results</a> which can be accessed by a <code>promise_result</code> import <a href="RuntimeSpec/Components/BindingsSpec/PromisesAPI.html">PromisesAPI</a> <code>promise_result</code>)</li>
<li>the original Transaction <code>signer_id</code>, <code>signer_public_key</code> data from the ActionReceipt (e.g. <code>method_name</code>, <code>args</code>, <code>predecessor_id</code>, <code>deposit</code>, <code>prepaid_gas</code> (which is <code>gas</code> in FunctionCall))</li>
<li>a general blockchain data (e.g. <code>block_index</code>, <code>block_timestamp</code>)</li>
<li>read data from the account storage</li>
</ul>
<p>A full list of the data available for the contract can be found in <a href="RuntimeSpec/Components/BindingsSpec/ContextAPI.html">Context API</a> and <a href="RuntimeSpec/Components/BindingsSpec/TrieAPI.html">Trie</a></p>
<h2><a class="header" href="#execution" id="execution">Execution</a></h2>
<p>First of all, runtime does prepare the Wasm binary to be executed:</p>
<ul>
<li>loads the contract code from the <code>receiver_id</code> <a href="RuntimeSpec/../Primitives/Account.html#account">account</a> storage</li>
<li>deserializes and validates the <code>code</code> Wasm binary (see <code>prepare::prepare_contract</code>)</li>
<li>injects the gas counting function <code>gas</code> which will charge gas on the beginning of the each code block</li>
<li>instantiates <a href="RuntimeSpec/Components/BindingsSpec/BindingsSpec.html">Bindings Spec</a> with binary and calls the <code>FunctionCall.method_name</code> exported function</li>
</ul>
<p>During execution, VM does the following:</p>
<ul>
<li>counts burnt gas on execution</li>
<li>counts used gas (which is <code>burnt gas</code> + gas attached to the new created receipts)</li>
<li>counts how accounts storage usage increased by the call</li>
<li>collects logs produced by the contract</li>
<li>sets the return data</li>
<li>creates new receipts through <a href="RuntimeSpec/Components/BindingsSpec/PromisesAPI.html">PromisesAPI</a></li>
</ul>
<h2><a class="header" href="#output" id="output">Output</a></h2>
<p>The output of the <code>FunctionCall</code>:</p>
<ul>
<li>storage updates - changes to the account trie storage which will be applied on a successful call</li>
<li><code>burnt_gas</code> - irreversible amount of gas witch was spent on computations</li>
<li><code>used_gas</code> - includes <code>burnt_gas</code> and gas attached to the new <code>ActionReceipt</code>s created during the method execution. In case of failure, created <code>ActionReceipt</code>s not going to be sent thus account will pay only for <code>burnt_gas</code></li>
<li><code>balance</code> - unspent account balance (account balance could be spent on deposits of newly created <code>FunctionCall</code>s or <a href="RuntimeSpec/Actions.html#transferaction"><code>TransferAction</code>s</a> to other contracts)</li>
<li><code>storage_usage</code> - storage_usage after ActionReceipt application</li>
<li><code>logs</code> - during contract execution, utf8/16 string log records could be created. Logs are not persistent currently.</li>
<li><code>new_receipts</code> - new <code>ActionReceipts</code> created during the execution. These receipts are going to be sent to the respective <code>receiver_id</code>s (see <a href="RuntimeSpec/FunctionCall.html#receipt-matching">Receipt Matching explanation</a>)</li>
<li>result could be either <a href="RuntimeSpec/FunctionCall.html#value-result"><code>ReturnData::Value(Vec&lt;u8&gt;)</code></a> or <a href="RuntimeSpec/FunctionCall.html#receiptindex-result"><code>ReturnData::ReceiptIndex(u64)</code></a>`</li>
</ul>
<h3><a class="header" href="#value-result" id="value-result">Value Result</a></h3>
<p>If applied <code>ActionReceipt</code> contains <a href="RuntimeSpec/Receitps.html#output_data_receivers"><code>output_data_receivers</code></a>, runtime will create <code>DataReceipt</code> for each of <code>data_id</code> and <code>receiver_id</code> and <code>data</code> equals returned value. Eventually, these <code>DataReceipt</code> will be delivered to the corresponding receivers.</p>
<h3><a class="header" href="#receiptindex-result" id="receiptindex-result">ReceiptIndex Result</a></h3>
<p>Successful result could not return any Value, but generates a bunch of new ActionReceipts instead. One example could be a callback. In this case, we assume the the new Receipt will send its Value Result to the <a href="RuntimeSpec/Receitps.html#output_data_receivers"><code>output_data_receivers</code></a> of the current <code>ActionReceipt</code>.</p>
<h1><a class="header" href="#transactions" id="transactions">Transactions</a></h1>
<p>A transaction in Near is a list of <a href="RuntimeSpec/Actions.html">actions</a> and additional information:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Transaction {
    /// An account on which behalf transaction is signed
    pub signer_id: AccountId,
    /// An access key which was used to sign a transaction
    pub public_key: PublicKey,
    /// Nonce is used to determine order of transaction in the pool.
    /// It increments for a combination of `signer_id` and `public_key`
    pub nonce: Nonce,
    /// Receiver account for this transaction. If
    pub receiver_id: AccountId,
    /// The hash of the block in the blockchain on top of which the given transaction is valid
    pub block_hash: CryptoHash,
    /// A list of actions to be applied
    pub actions: Vec&lt;Action&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#signed-transaction" id="signed-transaction">Signed Transaction</a></h2>
<p><code>SignedTransaction</code> is what the node receives from a wallet through JSON-RPC endpoint and then routed to the shard where <code>receiver_id</code> account lives. Signature proves an ownership of the corresponding <code>public_key</code> (which is an AccessKey for a particular account) as well as authenticity of the transaction itself.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct SignedTransaction {
    pub transaction: Transaction,
    /// A signature of a hash of the Borsh-serialized Transaction
    pub signature: Signature,
<span class="boring">}
</span></code></pre></pre>
<p>Take a look some <a href="RuntimeSpec/Scenarios/Scenarios.html">scenarios</a> how transaction can be applied.</p>
<h1><a class="header" href="#actions" id="actions">Actions</a></h1>
<p>There are a several action types in Near:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub enum Action {
    CreateAccount(CreateAccountAction),
    DeployContract(DeployContractAction),
    FunctionCall(FunctionCallAction),
    Transfer(TransferAction),
    Stake(StakeAction),
    AddKey(AddKeyAction),
    DeleteKey(DeleteKeyAction),
    DeleteAccount(DeleteAccountAction),
}
<span class="boring">}
</span></code></pre></pre>
<p>Each transaction consists a list of actions to be performed on the <code>receiver_id</code> side. Sometimes the <code>singer_id</code> equals to <code>receiver_id</code>. There is a set of action types when <code>signer_id</code> and <code>receiver_id</code> are required to be equal. Actions requires arguments and use data from the <code>Transaction</code> itself.</p>
<p>// TODO: how to introduce the concept of <code>sender_id</code></p>
<h2><a class="header" href="#createaccountaction" id="createaccountaction">CreateAccountAction</a></h2>
<p><em>Requirements:</em></p>
<ul>
<li><em>unique <code>tx.receiver_id</code></em></li>
<li><em><code>public_key</code> to be <code>AccessKeyPermission::FullAccess</code> for the <code>singer_id</code></em></li>
</ul>
<p><code>CreateAccountAction</code> doesn't take any additional arguments, it uses <code>receiver_id</code> from Transaction. <code>receiver_id</code> is an ID for an account to be created. Account ID should be <a href="RuntimeSpec/Account.html#account-id">valid</a> and <strong>unique</strong> throughout the system.</p>
<p><strong>Outcome</strong>:</p>
<ul>
<li>creates an account with <code>id</code> = <code>receiver_id</code></li>
<li>sets Account <code>storage_usage</code> to <code>account_cost</code> (genesis config)</li>
<li>sets Account <code>storage_paid_at</code> to the current block height</li>
</ul>
<p>NOTE: for the all subsequent actions in the transaction the <code>signer_id</code> becomes <code>receiver_id</code> until <a href="RuntimeSpec/Actions.html#DeleteAccountAction">DeleteAccountAction</a>. It allows to execute actions on behalf of the just created account.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct CreateAccountAction {}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#deploycontractaction" id="deploycontractaction">DeployContractAction</a></h2>
<p><em>Requirements:</em></p>
<ul>
<li><em><code>tx.signer_id</code> to be equal to <code>receiver_id</code></em></li>
<li><em><code>tx.public_key</code> to be <code>AccessKeyPermission::FullAccess</code> for the <code>singer_id</code></em></li>
</ul>
<p><strong>Outcome</strong>:</p>
<ul>
<li>sets a code for account</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct DeployContractAction {
    pub code: Vec&lt;u8&gt;, // a valid WebAssembly code
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#functioncallaction" id="functioncallaction">FunctionCallAction</a></h2>
<p><em>Requirements:</em></p>
<ul>
<li><em><code>tx.public_key</code> to be <code>AccessKeyPermission::FullAccess</code> or <code>AccessKeyPermission::FunctionCall</code></em></li>
</ul>
<p>Calls a method of a particular contract. See <a href="RuntimeSpec/./FunctionCall.html">details</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct FunctionCallAction {
    /// Name of exported Wasm function
    pub method_name: String,
    /// Serialized arguments
    pub args: Vec&lt;u8&gt;,
    /// Prepaid gas (gas_limit) for a function call
    pub gas: Gas,
    /// Amount of tokens to transfer to a receiver_id
    pub deposit: Balance,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#transferaction" id="transferaction">TransferAction</a></h2>
<p><em>Requirements:</em></p>
<ul>
<li><em><code>tx.public_key</code> to be <code>AccessKeyPermission::FullAccess</code> for the <code>singer_id</code></em></li>
</ul>
<p><strong>Outcome</strong>:</p>
<ul>
<li>transfers amount specified in <code>deposit</code> from <code>tx.signer</code> to a <code>tx.receiver_id</code> account</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct TransferAction {
    /// Amount of tokens to transfer to a receiver_id
    pub deposit: Balance,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#stakeaction" id="stakeaction">StakeAction</a></h2>
<p><em>Requirements:</em></p>
<ul>
<li><em><code>tx.signer_id</code> to be equal to <code>receiver_id</code></em></li>
<li><em><code>tx.public_key</code> to be <code>AccessKeyPermission::FullAccess</code> for the <code>singer_id</code></em></li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct StakeAction {
    // Amount of tokens to stake
    pub stake: Balance,
    // This public key is a public key of the validator node
    pub public_key: PublicKey,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Outcome</strong>:</p>
<pre><code>// TODO: cover staking
</code></pre>
<h2><a class="header" href="#addkeyaction" id="addkeyaction">AddKeyAction</a></h2>
<p><em>Requirements:</em></p>
<ul>
<li><em><code>tx.signer_id</code> to be equal to <code>receiver_id</code></em></li>
<li><em><code>tx.public_key</code> to be <code>AccessKeyPermission::FullAccess</code> for the <code>singer_id</code></em></li>
</ul>
<p>Associates an <a href="RuntimeSpec/AccessKey">AccessKey</a> with a <code>public_key</code> provided.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct AddKeyAction {
    pub public_key: PublicKey,
    pub access_key: AccessKey,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#deletekeyaction" id="deletekeyaction">DeleteKeyAction</a></h2>
<p><em>Requirements:</em></p>
<ul>
<li><em><code>tx.signer_id</code> to be equal to <code>receiver_id</code></em></li>
<li><em><code>tx.public_key</code> to be <code>AccessKeyPermission::FullAccess</code> for the <code>singer_id</code></em></li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct DeleteKeyAction {
    pub public_key: PublicKey,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#deleteaccountaction" id="deleteaccountaction">DeleteAccountAction</a></h2>
<p><em>Requirements:</em></p>
<ul>
<li><em><code>tx.signer_id</code> to be equal to <code>receiver_id</code></em></li>
<li><em><code>tx.public_key</code> to be <code>AccessKeyPermission::FullAccess</code> for the <code>singer_id</code></em></li>
<li><em><code>tx.account shouldn't have any locked balance</code></em></li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct DeleteAccountAction {
    /// The remaining account balance will be transferred to the AccountId below
    pub beneficiary_id: AccountId,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#receipt" id="receipt">Receipt</a></h1>
<p>All cross-contract (we assume that each account lives in it's own shard) communication in Near happens trough Receipts.
Receipts are stateful in a sense that they serve not only as messages between accounts but also can be stored in the account storage to await DataReceipts.</p>
<p>Each receipt has a <a href="RuntimeSpec/Receipts.html#predecessor_id"><code>predecessor_id</code></a> (who sent it) and <a href="RuntimeSpec/Receipts.html#receiver_id"><code>receiver_id</code></a> the current account.</p>
<p>Receipts are one of 2 types: action receipts or data receipts.</p>
<p>Data Receipts are receipts that contains some data for some <code>ActionReceipt</code> with the same <code>receiver_id</code>.
Data Receipts has 2 fields: the unique data identifier <code>data_id</code> and <code>data</code> the received result.
<code>data</code> is an <code>Option</code> field and it indicates whether the result was a success or a failure. If it's <code>Some</code>, then it means
the remote execution was successful and it contains the vector of bytes of the result.</p>
<p>Each <code>ActionReceipt</code> also contains fields related to data:</p>
<ul>
<li><a href="RuntimeSpec/Receipts.html#input_data_ids"><code>input_data_ids</code></a> - a vector of input data with the <code>data_id</code>s required for the execution of this receipt.</li>
<li><a href="RuntimeSpec/Receipts.html#output_data_receivers"><code>output_data_receivers</code></a> - a vector of output data receivers. It indicates where to send outgoing data.
Each <code>DataReceiver</code> consists of <code>data_id</code> and <code>receiver_id</code> for routing.</li>
</ul>
<p>Before any action receipt is executed, all input data dependencies need to be satisfied.
Which means all corresponding data receipts has to be received.
If any of the data dependencies is missing, the action receipt is postponed until all missing data dependency arrives.</p>
<p>Because Chain and Runtime guarantees that no receipts are missing, we can rely that every action receipt will be executed eventually (<a href="RuntimeSpec/Receipts.html#receipt-matching">Receipt Matching explanation</a>).</p>
<p>Each <code>Receipt</code> has the following fields:</p>
<h4><a class="header" href="#predecessor_id" id="predecessor_id">predecessor_id</a></h4>
<ul>
<li><strong><code>type</code></strong>: <code>AccountId</code></li>
</ul>
<p>The account_id which issued a receipt.</p>
<h4><a class="header" href="#receiver_id" id="receiver_id">receiver_id</a></h4>
<ul>
<li><strong><code>type</code></strong>: <code>AccountId</code></li>
</ul>
<p>The destination account_id.</p>
<h4><a class="header" href="#receipt_id" id="receipt_id">receipt_id</a></h4>
<ul>
<li><strong><code>type</code></strong>: <code>AccountId</code></li>
</ul>
<p>An unique id for the receipt.</p>
<h4><a class="header" href="#receipt-1" id="receipt-1">receipt</a></h4>
<ul>
<li><strong><code>type</code></strong>: <a href="RuntimeSpec/Receipts.html#actionreceipt">ActionReceipt</a> | <a href="RuntimeSpec/Receipts.html#datareceipt">DataReceipt</a></li>
</ul>
<p>There is a 2 types of Receipts in Near: <a href="RuntimeSpec/Receipts.html#actionreceipt">ActionReceipt</a> and <a href="RuntimeSpec/Receipts.html#datareceipt">DataReceipt</a>. ActionReceipt is a request to apply <a href="RuntimeSpec/Actions.html">Actions</a>, while DataReceipt is a result of application of these actions.</p>
<h2><a class="header" href="#actionreceipt" id="actionreceipt">ActionReceipt</a></h2>
<p><code>ActionReceipt</code> represents a request to apply actions on the <code>receiver_id</code> side. It could be a derived as a result of a <code>Transaction</code> execution or a another <code>ActionReceipt</code> processing. <code>ActionReceipt</code> consists the following fields:</p>
<h4><a class="header" href="#signer_id" id="signer_id">signer_id</a></h4>
<ul>
<li><strong><code>type</code></strong>: <code>AccountId</code></li>
</ul>
<p>An account_id which signed the original <a href="RuntimeSpec/Transaction.html">transaction</a>.</p>
<h4><a class="header" href="#signer_public_key" id="signer_public_key">signer_public_key</a></h4>
<ul>
<li><strong><code>type</code></strong>: <code>PublicKey</code></li>
</ul>
<p>An <a href="RuntimeSpec/../Primitives/AccessKey.html">AccessKey</a> which was used to sign the original transaction.</p>
<h4><a class="header" href="#gas_price" id="gas_price">gas_price</a></h4>
<ul>
<li><strong><code>type</code></strong>: <code>u128</code></li>
</ul>
<p>Gas price is a gas price which was set in a block where original <a href="RuntimeSpec/Transaction.html">transaction</a> has been applied.</p>
<h4><a class="header" href="#output_data_receivers" id="output_data_receivers">output_data_receivers</a></h4>
<ul>
<li><strong><code>type</code></strong>: <code>[DataReceiver{ data_id: CryptoHash, receiver_id: AccountId }]</code></li>
</ul>
<p>If smart contract finishes its execution with some value (not Promise), runtime creates a [<code>DataReceipt</code>]s for each of the <code>output_data_receivers</code>.</p>
<h4><a class="header" href="#input_data_ids" id="input_data_ids">input_data_ids</a></h4>
<ul>
<li><strong><code>type</code></strong>: <code>[CryptoHash]_</code></li>
</ul>
<p><code>input_data_ids</code> are the receipt data dependencies. <code>input_data_ids</code> correspond to <code>DataReceipt.data_id</code>.</p>
<h4><a class="header" href="#actions-1" id="actions-1">actions</a></h4>
<ul>
<li><strong><code>type</code></strong>: <a href="RuntimeSpec/Actions.html#functioncallaction"><code>FunctionCall</code></a> | <a href="RuntimeSpec/Actions.html#transferaction"><code>TransferAction</code></a> | <a href="RuntimeSpec/Actions.html#stakeaction"><code>StakeAction</code></a> | <a href="RuntimeSpec/Actions.html#addkeyaction"><code>AddKeyAction</code></a> | <a href="RuntimeSpec/Actions.html#deletekeyaction"><code>DeleteKeyAction</code></a> | <a href="RuntimeSpec/Actions.html#createaccountaction"><code>CreateAccountAction</code></a> | <a href="RuntimeSpec/Actions.html#deleteaccountaction"><code>DeleteAccountAction</code></a></li>
</ul>
<h2><a class="header" href="#datareceipt" id="datareceipt">DataReceipt</a></h2>
<p>DataReceipt represents a final result of some contract execution.</p>
<h4><a class="header" href="#data_id" id="data_id">data_id</a></h4>
<ul>
<li><strong><code>type</code></strong>: <code>CryptoHash</code></li>
</ul>
<p>An a unique DataReceipt identifier.</p>
<h4><a class="header" href="#data" id="data">data</a></h4>
<ul>
<li><strong><code>type</code></strong>: <code>Option([u8])</code></li>
</ul>
<p>An an associated data in bytes. <code>None</code> indicates an error during execution.</p>
<h1><a class="header" href="#creating-receipt" id="creating-receipt">Creating Receipt</a></h1>
<p>Receipts can be generated during the execution of the <a href="RuntimeSpec/./Transactions.html#SignedTransaction">SignedTransaction</a> (see <a href="RuntimeSpec/./Scenarios/FinancialTransaction.html">example</a>) or during application of some <code>ActionReceipt</code> which contains <a href="RuntimeSpec/Receipts.html#actions"><code>FunctionCall</code></a> action. The result of the <code>FunctionCall</code> could either</p>
<h1><a class="header" href="#receipt-matching" id="receipt-matching">Receipt Matching</a></h1>
<p>Runtime doesn't expect that Receipts are coming in a particular order. Each Receipt is processed individually. The goal of the <code>Receipt Matching</code> process is to match all <a href="RuntimeSpec/Receipts.html#actionreceipt"><code>ActionReceipt</code>s</a> to the corresponding <a href="RuntimeSpec/Receipts.html#datareceipt"><code>DataReceipt</code>s</a>.</p>
<h2><a class="header" href="#processing-actionreceipt" id="processing-actionreceipt">Processing ActionReceipt</a></h2>
<p>For each incoming <a href="RuntimeSpec/Receipts.html#actionreceipt"><code>ActionReceipt</code></a> runtime checks whether we have all the <a href="RuntimeSpec/Receipts.html#datareceipt"><code>DataReceipt</code>s</a> (defined as <a href="RuntimeSpec/Receipts.html#input_data_ids"><code>ActionsReceipt.input_data_ids</code></a>) required for execution. If all the required <a href="RuntimeSpec/Receipts.html#datareceipt"><code>DataReceipt</code>s</a> are already in the <a href="RuntimeSpec/Receipts.html#received-datareceipt">storage</a>, runtime can apply this <code>ActionReceipt</code> immediately. Otherwise we save this receipt as a <a href="RuntimeSpec/Receipts.html#postponed-actionreceipt">Postponed ActionReceipt</a>. Also we save <a href="RuntimeSpec/Receipts.html#pending-datareceipt-count">Pending DataReceipts Count</a> and <a href="RuntimeSpec/Receipts.html#pending-datareceipt-for-postponed-actionreceipt">a link from pending <code>DataReceipt</code> to the <code>Postponed ActionReceipt</code></a>. Now runtime will wait all the missing <code>DataReceipt</code>s to apply the <code>Postponed ActionReceipt</code>.</p>
<h4><a class="header" href="#postponed-actionreceipt" id="postponed-actionreceipt">Postponed ActionReceipt</a></h4>
<p>A Receipt which runtime stores until all the designated <a href="RuntimeSpec/Receipts.html#datareceipt"><code>DataReceipt</code>s</a> arrive.</p>
<ul>
<li><strong><code>key</code></strong> = <code>account_id</code>,<code>receipt_id</code></li>
<li><strong><code>value</code></strong> = <code>[u8]</code></li>
</ul>
<p><em>Where <code>account_id</code> is <a href="RuntimeSpec/Receipts.html#receiver_id"><code>Receipt.receiver_id</code></a>, <code>receipt_id</code> is <a href="RuntimeSpec/Receipts.html#receipt_id"><code>Receipt.receiver_id</code></a> and value is a serialized <a href="RuntimeSpec/Receipts.html#receipt"><code>Receipt</code></a> (which <a href="RuntimeSpec/Receipts.html#type">type</a> must be <a href="RuntimeSpec/Receipts.html#actionreceipt">ActionReceipt</a>).</em></p>
<h4><a class="header" href="#pending-datareceipt-count" id="pending-datareceipt-count">Pending DataReceipt Count</a></h4>
<p>A counter which counts pending <a href="RuntimeSpec/Receipts.html#DataReceipt"><code>DataReceipt</code>s</a> for a <a href="RuntimeSpec/Receipts.html#postponed-receipt">Postponed Receipt</a> initially set to the length of missing <a href="RuntimeSpec/Receipts.html#input_data_ids"><code>input_data_ids</code></a> of the incoming <code>ActionReceipt</code>. It's decrementing with every new received <a href="RuntimeSpec/Receipts.html#datareceipt"><code>DataReceipt</code></a>:</p>
<ul>
<li><strong><code>key</code></strong> = <code>account_id</code>,<code>receipt_id</code></li>
<li><strong><code>value</code></strong> = <code>u32</code></li>
</ul>
<p><em>Where <code>account_id</code> is AccountId, <code>receipt_id</code> is CryptoHash and value is an integer.</em></p>
<h4><a class="header" href="#pending-datareceipt-for-postponed-actionreceipt" id="pending-datareceipt-for-postponed-actionreceipt">Pending DataReceipt for Postponed ActionReceipt</a></h4>
<p>We index each pending <code>DataReceipt</code> so when a new <a href="RuntimeSpec/Receipts.html#datareceipt"><code>DataReceipt</code></a> arrives we can find to which <a href="RuntimeSpec/Receipts.html#postponed-receipt">Postponed Receipt</a> it belongs.</p>
<ul>
<li><strong><code>key</code></strong> = <code>account_id</code>,<code>data_id</code></li>
<li><strong><code>value</code></strong> = <code>receipt_id</code></li>
</ul>
<h2><a class="header" href="#processing-datareceipt" id="processing-datareceipt">Processing DataReceipt</a></h2>
<h4><a class="header" href="#received-datareceipt" id="received-datareceipt">Received DataReceipt</a></h4>
<p>First of all, runtime saves the incoming <code>DataReceipt</code> to the storage as:</p>
<ul>
<li><strong><code>key</code></strong> = <code>account_id</code>,<code>data_id</code></li>
<li><strong><code>value</code></strong> = <code>[u8]</code></li>
</ul>
<p><em>Where <code>account_id</code> is <a href="RuntimeSpec/Receipts.html#receiver_id"><code>Receipt.receiver_id</code></a>, <code>data_id</code> is <a href="RuntimeSpec/Receipts.html#data_id"><code>DataReceipt.data_id</code></a> and value is a <a href="RuntimeSpec/Receipts.html#data"><code>DataReceipt.data</code></a> (which is typically a serialized result of the call to a particular contract).</em></p>
<p>Next, runtime checks if there is any <a href="RuntimeSpec/Receipts.html#postponed-actionreceipt"><code>Postponed ActionReceipt</code></a> awaits for this <code>DataReceipt</code> by querying <a href="RuntimeSpec/Receipts.html#pending-datareceipt-for-postponed-actionReceipt"><code>Pending DataReceipt</code> to the Postponed Receipt</a>. If there is no postponed <code>receipt_id</code> yet, we do nothing else. If there is a postponed <code>receipt_id</code>, we do the following:</p>
<ul>
<li>decrement <a href="RuntimeSpec/Receipts.html#pending-datareceipt-count"><code>Pending Data Count</code></a> for the postponed <code>receipt_id</code></li>
<li>remove found <a href="RuntimeSpec/Receipts.html#pending-datareceipt-for-postponed-actionreceipt"><code>Pending DataReceipt</code> to the <code>Postponed ActionReceipt</code></a></li>
</ul>
<p>If <a href="RuntimeSpec/Receipts.html#pending-datareceipt-count"><code>Pending DataReceipt Count</code></a> is now 0 that means all the <a href="RuntimeSpec/Receipts.html#input_data_ids"><code>Receipt.input_data_ids</code></a> are in storage and runtime can safely apply the <a href="RuntimeSpec/Receipts.html#postponed-receipt">Postponed Receipt</a> and remove it from the store.</p>
<h2><a class="header" href="#case-1-call-to-multiple-contracts-and-await-responses" id="case-1-call-to-multiple-contracts-and-await-responses">Case 1: Call to multiple contracts and await responses</a></h2>
<p>Suppose runtime got the following <code>ActionReceipt</code>:</p>
<pre><code class="language-python"># Non-relevant fields are omitted.
Receipt{
    receiver_id: &quot;alice&quot;,
    receipt_id: &quot;693406&quot;
    receipt: ActionReceipt {
        input_data_ids: []
    }
}
</code></pre>
<p>If execution return Result::Value</p>
<p>Suppose runtime got the following <code>ActionReceipt</code> (we use a python-like pseudo code):</p>
<pre><code class="language-python"># Non-relevant fields are omitted.
Receipt{
    receiver_id: &quot;alice&quot;,
    receipt_id: &quot;5e73d4&quot;
    receipt: ActionReceipt {
        input_data_ids: [&quot;e5fa44&quot;, &quot;7448d8&quot;]
    }
}
</code></pre>
<p>We can't apply this receipt right away: there are missing DataReceipt'a with IDs: [&quot;e5fa44&quot;, &quot;7448d8&quot;]. Runtime does the following:</p>
<pre><code class="language-python">postponed_receipts[&quot;alice,5e73d4&quot;] = borsh_serialize(
    Receipt{
        receiver_id: &quot;alice&quot;,
        receipt_id: &quot;5e73d4&quot;
        receipt: ActionReceipt {
            input_data_ids: [&quot;e5fa44&quot;, &quot;7448d8&quot;]
        }
    }
)
pending_data_receipt_store[&quot;alice,e5fa44&quot;] = &quot;5e73d4&quot;
pending_data_receipt_store[&quot;alice,7448d8&quot;] = &quot;5e73d4&quot;
pending_data_receipt_count = 2
</code></pre>
<p><em>Note: the subsequent Receipts could arrived in the current block or next, that's why we save <a href="RuntimeSpec/Receipts.html#postponed-actionreceipt">Postponed ActionReceipt</a> in the storage</em></p>
<p>Then the first pending <code>Pending DataReceipt</code> arrives:</p>
<pre><code class="language-python"># Non-relevant fields are omitted.
Receipt {
    receiver_id: &quot;alice&quot;,
    receipt: DataReceipt {
        data_id: &quot;e5fa44&quot;,
        data: &quot;some data for alice&quot;,
    }
}
</code></pre>
<pre><code class="language-python">data_receipts[&quot;alice,e5fa44&quot;] = borsh_serialize(Receipt{
    receiver_id: &quot;alice&quot;,
    receipt: DataReceipt {
        data_id: &quot;e5fa44&quot;,
        data: &quot;some data for alice&quot;,
    }
};
pending_data_receipt_count[&quot;alice,5e73d4&quot;] = 1`
del pending_data_receipt_store[&quot;alice,e5fa44&quot;]
</code></pre>
<p>And finally the last <code>Pending DataReceipt</code> arrives:</p>
<pre><code class="language-python"># Non-relevant fields are omitted.
Receipt{
    receiver_id: &quot;alice&quot;,
    receipt: DataReceipt {
        data_id: &quot;7448d8&quot;,
        data: &quot;some more data for alice&quot;,
    }
}
</code></pre>
<pre><code class="language-python">data_receipts[&quot;alice,7448d8&quot;] = borsh_serialize(Receipt{
    receiver_id: &quot;alice&quot;,
    receipt: DataReceipt {
        data_id: &quot;7448d8&quot;,
        data: &quot;some more data for alice&quot;,
    }
};
postponed_receipt_id = pending_data_receipt_store[&quot;alice,5e73d4&quot;]
postponed_receipt = postponed_receipts[postponed_receipt_id]
del postponed_receipts[postponed_receipt_id]
del pending_data_receipt_count[&quot;alice,5e73d4&quot;]
del pending_data_receipt_store[&quot;alice,7448d8&quot;]
apply_receipt(postponed_receipt)
</code></pre>
<h1><a class="header" href="#scenarios" id="scenarios">Scenarios</a></h1>
<p>In the following sections we go over the common scenarios that runtime takes care of.</p>
<h1><a class="header" href="#financial-transaction" id="financial-transaction">Financial Transaction</a></h1>
<p>Suppose Alice wants to transfer 100 tokens to Bob.
In this case we are talking about native Near Protocol tokens, oppose to user-defined tokens implemented through a smart contract.
There are several way this can be done:</p>
<ul>
<li>Direct transfer through a transaction containing transfer action;</li>
<li>Alice calling a smart contract that in turn creates a financial transaction towards Bob.</li>
</ul>
<p>In this section we are talking about the former simpler scenario.</p>
<h2><a class="header" href="#pre-requisites" id="pre-requisites">Pre-requisites</a></h2>
<p>For this to work both Alice and Bob need to have <em>accounts</em> and an access to them through
<em>the full access keys</em>.</p>
<p>Suppose Alice has account <code>alice_near</code> and Bob has account <code>bob_near</code>. Also, some time in the past,
each of them has created a public-secret key-pair, saved the secret key somewhere (e.g. in a wallet application)
and created a full access key with the public key for the account.</p>
<p>We also need to assume that both Alice and Bob has some number of tokens on their accounts. Alice needs &gt;100 tokens on the account
so that she could transfer 100 tokens to Bob, but also Alice and Bob need to have some tokens to pay for the <em>rent</em> of their account --
which is essentially the cost of the storage occupied by the account in the Near Protocol network.</p>
<h2><a class="header" href="#creating-a-transaction" id="creating-a-transaction">Creating a transaction</a></h2>
<p>To send the transaction neither Alice nor Bob need to run a node.
However, Alice needs a way to create and sign a transaction structure.
Suppose Alice uses near-shell or any other third-party tool for that.
The tool then creates the following structure:</p>
<pre><code>Transaction {
    signer_id: &quot;alice_near&quot;,
    public_key: &quot;ed25519:32zVgoqtuyRuDvSMZjWQ774kK36UTwuGRZMmPsS6xpMy&quot;,
    nonce: 57,
    receiver_id: &quot;bob_near&quot;,
    block_hash: &quot;CjNSmWXTWhC3EhRVtqLhRmWMTkRbU96wUACqxMtV1uGf&quot;,
    actions: vec![
        Action::Transfer(TransferAction {deposit: 100} )
    ],
}
</code></pre>
<p>Which contains one token transfer action, the id of the account that signs this transaction (<code>alice_near</code>)
the account towards which this transaction is addressed (<code>bob_near</code>). Alice also uses the public key
associated with one of the full access keys of <code>alice_near</code> account.</p>
<p>Additionally, Alice uses the <em>nonce</em> which is unique value that allows Near Protocol to differentiate the transactions (in case there are several transfers coming in rapid
succession) which should be strictly increasing with each transaction. Unlike in Ethereum, nonces are associated with access keys, oppose to
the entire accounts, so several users using the same account through different access keys need not to worry about accidentally
reusing each other's nonces.</p>
<p>The block hash is used to calculate the transaction &quot;freshness&quot;. It is used to make sure the transaction does
not get lost (let's say somewhere in the network) and then arrive hours, days, or years later when it is not longer relevant
or would be undesirable to execute. The transaction does not need to arrive at the specific block, instead it is required to
arrive within certain number of blocks from the bock identified by the <code>block_hash</code> (as of 2019-10-27 the constant is 10 blocks).
Any transaction arriving outside this threshold is considered to be invalid.</p>
<p>near-shell or other tool that Alice uses then signs this transaction, by: computing the hash of the transaction and signing it
with the secret key, resulting in a <code>SignedTransaction</code> object.</p>
<h2><a class="header" href="#sending-the-transaction" id="sending-the-transaction">Sending the transaction</a></h2>
<p>To send the transaction, near-shell connects through the RPC to any Near Protocol node and submits it.
If users wants to wait until the transaction is processed they can use <code>send_tx_commit</code> JSONRPC method which waits for the
transaction to appear in a block. Otherwise the user can use <code>send_tx_async</code>.</p>
<h2><a class="header" href="#transaction-to-receipt" id="transaction-to-receipt">Transaction to receipt</a></h2>
<p>We skip the details on how the transaction arrives to be processed by the runtime, since it is a part of the blockchain layer
discussion.
We consider the moment where <code>SignedTransaction</code> is getting passed to <code>Runtime::apply</code> of the
<code>runtime</code> crate.
<code>Runtime::apply</code> immediately passes transaction to <code>Runtime::process_transaction</code>
which in turn does the following:</p>
<ul>
<li>Verifies that transaction is valid;</li>
<li>Applies initial reversible and irreversible charges to <code>alice_near</code> account;</li>
<li>Creates a receipt with the same set of actions directed towards <code>bob_near</code>.</li>
</ul>
<p>The first two items are performed inside <code>Runtime::verify_and_charge_transaction</code> method.
Specifically it does the following checks:</p>
<ul>
<li>Verifies that <code>alice_near</code> and <code>bob_near</code> are syntactically valid account ids;</li>
<li>Verifies that the signature of the transaction is correct based on the transaction hash and the attached public key;</li>
<li>Retrieves the latest state of the <code>alice_near</code> account, and simultaneously checks that it exists;</li>
<li>Retrieves the state of the access key of that <code>alice_near</code> used to sign the transaction;</li>
<li>Checks that transaction nonce is greater than the nonce of the latest transaction executed with that access key;</li>
<li>Checks whether the account that signed the transaction is the same as the account that receives it. In our case the sender (<code>alice_near</code>) and the receiver (<code>bob_near</code>) are not the same. We apply different fees if receiver and sender is the same account;</li>
<li>Applies the storage rent to the <code>alice_near</code> account;</li>
<li>Computes how much gas we need to spend to convert this transaction to a receipt;</li>
<li>Computes how much balance we need to subtract from <code>alice_near</code>, in this case it is 100 tokens;</li>
<li>Deducts the tokens and the gas from <code>alice_near</code> balance, using the current gas price;</li>
<li>Checks whether after all these operations account has enough balance to passively pay for the rent for the next several blocks
(an economical constant defined by Near Protocol). Otherwise account will be open for an immediate deletion, which we do not want;</li>
<li>Updates the <code>alice_near</code> account with the new balance and the used access key with the new nonce;</li>
<li>Computes how much reward should be paid to the validators from the burnt gas.</li>
</ul>
<p>If any of the above operations fail all of the changes will be reverted.</p>
<h2><a class="header" href="#processing-receipt" id="processing-receipt">Processing receipt</a></h2>
<p>The receipt created in the previous section will eventually arrive to a runtime on the shard that hosts <code>bob_near</code> account.
Again, it will be processed by <code>Runtime::apply</code> which will immediately call <code>Runtime::process_receipt</code>.
It will check that this receipt does not have data dependencies (which is only the case of function calls) and will then call <code>Runtime::apply_action_receipt</code> on <code>TransferAction</code>.
<code>Runtime::apply_action_receipt</code> will perform the following checks:</p>
<ul>
<li>Retrieves the state of <code>bob_near</code> account, if it still exists (it is possible that Bob has deleted his account concurrently with the transfer transaction);</li>
<li>Applies the rent to Bob's account;</li>
<li>Computes the cost of processing a receipt and a transfer action;</li>
<li>Checks if <code>bob_near</code> still exists and if it is deposits the transferred tokens;</li>
<li>Computes how much reward should be paid to the validators from the burnt gas.</li>
</ul>
<h1><a class="header" href="#cross-contract-call" id="cross-contract-call">Cross-Contract Call</a></h1>
<p>This guide assumes that you have read the <a href="RuntimeSpec/Scenarios/FinancialTransaction.html">Financial Transaction</a> section.</p>
<p>Suppose Alice is a calling a function <code>reserve_trip(city: String, date: u64)</code> on a smart contract deployed to a <code>travel_agency</code>
account which in turn calls <code>reserve(date: u64)</code> on a smart contract deployed to a <code>hotel_near</code> account and attaches
a callback to method <code>hotel_reservation_complete(date: u64)</code> on <code>travel_agency</code>.</p>
<img src="RuntimeSpec/Scenarios/../../images/receipt_flow_diagram.svg" />
<h2><a class="header" href="#pre-requisites-1" id="pre-requisites-1">Pre-requisites</a></h2>
<p>It possible for Alice to call the <code>travel_agency</code> in several different ways.</p>
<p>In the simplest scenario Alice has an account <code>alice_near</code> and she has a full access key.
She then composes the following transaction that calls the <code>travel_agency</code>:</p>
<pre><code>Transaction {
    signer_id: &quot;alice_near&quot;,
    public_key: &quot;ed25519:32zVgoqtuyRuDvSMZjWQ774kK36UTwuGRZMmPsS6xpMy&quot;,
    nonce: 57,
    receiver_id: &quot;travel_agency&quot;,
    block_hash: &quot;CjNSmWXTWhC3EhRVtqLhRmWMTkRbU96wUACqxMtV1uGf&quot;,
    actions: vec![
        Action::FunctionCall(FunctionCallAction {
            method_name: &quot;reserve_trip&quot;,
            args: &quot;{\&quot;city\&quot;: \&quot;Venice\&quot;, \&quot;date\&quot;: 20191201}&quot;,
            gas: 1000000,
            tokens: 100,
        })
    ],
}
</code></pre>
<p>Here the public key corresponds to the full access key of <code>alice_near</code> account. All other fields in <code>Transaction</code> were
discussed in the <a href="RuntimeSpec/Scenarios/FinancialTransaction.html">Financial Transaction</a> section. The <code>FunctionCallAction</code> action describes how
the contract should be called. The <code>receiver_id</code> field in <code>Transaction</code> already establishes what contract should be executed,
<code>FunctionCallAction</code> merely describes how it should be executed. Interestingly, the arguments is just a blob of bytes,
it is up to the contract developer what serialization format they choose for their arguments. In this example, the contract
developer has chosen to use JSON and so the tool that Alice uses to compose this transaction is expected to use JSON too
to pass the arguments. <code>gas</code> declares how much gas <code>alice_near</code> has prepaid for dynamically calculated fees of the smart
contract executions and other actions that this transaction may spawn. The <code>tokens</code> is the amount of <code>alice_near</code> attaches
to be deposited to whatever smart contract that it is calling to. Notice, <code>gas</code> and <code>tokens</code> are in different units of
measurement.</p>
<p>Now, consider a slightly more complex scenario. In this scenario Alice uses a restricted access key to call the function.
That is the permission of the access key is not <code>AccessKeyPermission::FullAccess</code> but is instead: <code>AccessKeyPermission::FunctionCall(FunctionCallPermission)</code>
where</p>
<pre><code>FunctionCallPermission {
    allowance: Some(3000),
    receiver_id: &quot;travel_agency&quot;,
    method_names: [ &quot;reserve_trip&quot;, &quot;cancel_trip&quot; ]
}
</code></pre>
<p>This scenario might arise when someone Alice's parent has given them a restricted access to <code>alice_near</code> account by
creating an access key that can be used strictly for trip management.
This access key allows up to <code>3000</code> tokens to be spent (which includes token transfers and payments for gas), it can
be only used to call <code>travel_agency</code> and it can be only used with the <code>reserve_trip</code> and <code>cancel_trip</code> methods.
The way runtime treats this case is almost exactly the same as the previous one, with the only difference on how it verifies
the signature of on the signed transaction, and that it also checks for allowance to not be exceeded.</p>
<p>Finally, in the last scenario, Alice does not have an account (or the existence of <code>alice_near</code> is irrelevant). However,
alice has full or restricted access key directly on <code>travel_agency</code> account. In that case <code>signer_id == receiver_id</code> in the
<code>Transaction</code> object and runtime will convert transaction to the first receipt and apply that receipt in the same block.</p>
<p>This section will focus on the first scenario, since the other two are the same with some minor differences.</p>
<h2><a class="header" href="#transaction-to-receipt-1" id="transaction-to-receipt-1">Transaction to receipt</a></h2>
<p>The process of converting transaction to receipt is very similar to the <a href="RuntimeSpec/Scenarios/FinancialTransaction.html">Financial Transaction</a>
with several key points to note:</p>
<ul>
<li>Since Alice attaches 100 tokens to the function call, we subtract them from <code>alice_near</code> upon converting transaction to receipt,
similar to the regular financial transaction;</li>
<li>Since we are attaching 1000000 prepaid gas, we will not only subtract the gas costs of processing the receipt from <code>alice_near</code>, but
will also purchase 1000000 gas using the current gas price.</li>
</ul>
<h2><a class="header" href="#processing-the-reserve_trip-receipt" id="processing-the-reserve_trip-receipt">Processing the <code>reserve_trip</code> receipt</a></h2>
<p>The receipt created on the shard that hosts <code>alice_near</code> will eventually arrive to the shard hosting <code>travel_agency</code> account.
It will be processed in <code>Runtime::apply</code> which will check that receipt does not have data dependencies (which is the case because
this function call is not a callback) and will call <code>Runtime::apply_action_receipt</code>.
At this point receipt processing is similar to receipt processing from the <a href="RuntimeSpec/Scenarios/FinancialTransaction.html">Financial Transaction</a>
section, with one difference that we will also call <code>action_function_call</code> which will do the following:</p>
<ul>
<li>Retrieve the Wasm code of the smart contract (either from the database or from the cache);</li>
<li>Initialize runtime context through <code>VMContext</code> and create <code>RuntimeExt</code> which provides access to the trie when the smart contract
call the storage API. Specifically <code>&quot;{\&quot;city\&quot;: \&quot;Venice\&quot;, \&quot;date\&quot;: 20191201}&quot;</code> arguments will be set in <code>VMContext</code>.</li>
<li>Calls <code>near_vm_runner::run</code> which does the following:
<ul>
<li>Inject gas, stack, and other kinds of metering;</li>
<li>Verify that Wasm code does not use floats;</li>
<li>Checks that bindings API functions that the smart contract is trying to call are actually those provided by <code>near_vm_logic</code>;</li>
<li>Compiles Wasm code into the native binary;</li>
<li>Calls <code>reserve_trip</code> on the smart contract.
<ul>
<li>During the execution of the smart contract it will at some point call <code>promise_create</code> and <code>promise_then</code>, which will
call method on <code>RuntimeExt</code> that will record that two promises were created and that the second one should
wait on the first one. Specifically, <code>promise_create</code> will call <code>RuntimeExt::create_receipt(vec![], &quot;hotel_near&quot;)</code>
returning <code>0</code> and then <code>RuntimeExt::create_receipt(vec![0], &quot;travel_agency&quot;)</code>;</li>
</ul>
</li>
</ul>
</li>
<li><code>action_function_call</code> then collects receipts from <code>VMContext</code> along with the execution result, logs, and information
about used gas;</li>
<li><code>apply_action_receipt</code> then goes over the collected receipts from each action and returns them at the end of <code>Runtime::apply</code> together with
other receipts.</li>
</ul>
<h2><a class="header" href="#processing-the-reserve-receipt" id="processing-the-reserve-receipt">Processing the <code>reserve</code> receipt</a></h2>
<p>This receipt will have <code>output_data_receivers</code> with one element corresponding to the receipt that calls <code>hotel_reservation_complete</code>,
which will tell the runtime that it should create <code>DataReceipt</code> and send it towards <code>travel_agency</code> once the execution of <code>reserve(date: u64)</code> is complete.</p>
<p>The rest of the smart contract execution is similar to the above.</p>
<h2><a class="header" href="#processing-the-hotel_reservation_complete-receipt" id="processing-the-hotel_reservation_complete-receipt">Processing the <code>hotel_reservation_complete</code> receipt</a></h2>
<p>Upon receiving the <code>hotel_reservation_complete</code> receipt the runtime will notice that its <code>input_data_ids</code> is not empty
which means that it cannot be executed until <code>reserve</code> receipt is complete. It will store the receipt in the trie together
with the counter of how many <code>DataReceipt</code> it is waiting on.</p>
<p>It will not call the Wasm smart contract at this point.</p>
<h2><a class="header" href="#processing-the-datareceipt" id="processing-the-datareceipt">Processing the <code>DataReceipt</code></a></h2>
<p>Once the runtime receives the <code>DataReceipt</code> it takes the receipt with <code>hotel_reservation_complete</code> function call
and executes it following the same execution steps as with the <code>reserve_trip</code> receipt.</p>
<h1><a class="header" href="#components" id="components">Components</a></h1>
<p>Here is the high-level diagram of various runtime components, including some blockchain layer components.
<img src="RuntimeSpec/Components/../../images/runtime_architecture.svg" /></p>
<h1><a class="header" href="#runtime-crate" id="runtime-crate">Runtime crate</a></h1>
<p>Runtime crate encapsulates the logic of how transactions and receipts should be handled. If it encounters
a smart contract call within a transaction or a receipt it calls <code>near-vm-runner</code>, for all other actions, like account
creation, it processes them in-place.</p>
<h2><a class="header" href="#runtime-class" id="runtime-class">Runtime class</a></h2>
<p>The main entry point of the <code>Runtime</code> is method <code>apply</code>.
It applies new singed transactions and incoming receipts for some chunk/shard on top of
given trie and the given state root.
If the validator accounts update is provided, updates validators accounts.
All new signed transactions should be valid and already verified by the chunk producer.
If any transaction is invalid, the method returns an <code>InvalidTxError</code>.
In case of success, the method returns <code>ApplyResult</code> that contains the new state root, trie changes,
new outgoing receipts, stats for validators (e.g. total rent paid by all the affected accounts),
execution outcomes.</p>
<h3><a class="header" href="#apply-arguments" id="apply-arguments">Apply arguments</a></h3>
<p>It takes the following arguments:</p>
<ul>
<li><code>trie: Arc&lt;Trie&gt;</code> - the trie that contains the latest state.</li>
<li><code>root: CryptoHash</code> - the hash of the state root in the trie.</li>
<li><code>validator_accounts_update: &amp;Option&lt;ValidatorAccountsUpdate&gt;</code> - optional field that contains updates for validator accounts.
It's provided at the beginning of the epoch or when someone is slashed.</li>
<li><code>apply_state: &amp;ApplyState</code> - contains block index and timestamp, epoch length, gas price and gas limit.</li>
<li><code>prev_receipts: &amp;[Receipt]</code> - the list of incoming receipts, from the previous block.</li>
<li><code>transactions: &amp;[SignedTransaction]</code> - the list of new signed transactions.</li>
</ul>
<h3><a class="header" href="#apply-logic" id="apply-logic">Apply logic</a></h3>
<p>The execution consists of the following stages:</p>
<ol>
<li>Snapshot the initial state.</li>
<li>Apply validator accounts update, if available.</li>
<li>Convert new signed transactions into the receipts.</li>
<li>Process receipts.</li>
<li>Check that incoming and outgoing balances match.</li>
<li>Finalize trie update.</li>
<li>Return <code>ApplyResult</code>.</li>
</ol>
<h2><a class="header" href="#validator-accounts-update" id="validator-accounts-update">Validator accounts update</a></h2>
<p>Validator accounts are accounts that staked some tokens to become a validator.
The validator accounts update usually happens when the current chunk is the first chunk of the epoch.
It also happens when there is a challenge in the current block with one of the participants belong to the current shard.</p>
<p>This update distributes validator rewards, return locked tokens and maybe slashes some accounts out of their stake.</p>
<h2><a class="header" href="#signed-transaction-conversion" id="signed-transaction-conversion">Signed Transaction conversion</a></h2>
<p>New signed transaction transactions are provided by the chunk producer in the chunk. These transactions should be ordered and already validated.
Runtime does validation again for the following reasons:</p>
<ul>
<li>to charge accounts for transactions fees, transfer balances, prepaid gas and account rents;</li>
<li>to create new receipts;</li>
<li>to compute burnt gas;</li>
<li>to validate transactions again, in case the chunk producer was malicious.</li>
</ul>
<p>If the transaction has the the same <code>signer_id</code> and <code>receiver_id</code>, then the new receipt is added to the list of new local receipts,
otherwise it's added to the list of new outgoing receipts.</p>
<h2><a class="header" href="#receipt-processing" id="receipt-processing">Receipt processing</a></h2>
<p>Receipts are processed one by one in the following order:</p>
<ol>
<li>Previously delayed receipts from the state.</li>
<li>New local receipts.</li>
<li>New incoming receipts.</li>
</ol>
<p>After each processed receipt, we compare total gas burnt (so far) with the gas limit.
When the total gas burnt reaches or exceeds the gas limit, the processing stops.
The remaining receipts are considered delayed and stored into the state.</p>
<h3><a class="header" href="#delayed-receipts" id="delayed-receipts">Delayed receipts</a></h3>
<p>Delayed receipts are stored as a persistent queue in the state.
Initially, the first unprocessed index and the next available index are initialized to 0.
When a new delayed receipt is added, it's written under the next available index in to the state and the next available index is incremented by 1.
When a delayed receipt is processed, it's read from the state using the first unprocessed index and the first unprocessed index is incremented.
At the end of the receipt processing, the all remaining local and incoming receipts are considered to be delayed and stored to the state in their respective order.
If during receipt processing, we've changed indices, then the delayed receipt indices are stored to the state as well.</p>
<h3><a class="header" href="#receipt-processing-algorithm" id="receipt-processing-algorithm">Receipt processing algorithm</a></h3>
<p>The receipt processing algorithm is the following:</p>
<ol>
<li>Read indices from the state or initialize with zeros.</li>
<li>While the first unprocessed index is less than the next available index do the following
<ol>
<li>If the total burnt gas is at least the gas limit, break.</li>
<li>Read the receipt from the first unprocessed index.</li>
<li>Remove the receipt from the state.</li>
<li>Increment the first unprocessed index.</li>
<li>Process the receipt.</li>
<li>Add the new burnt gas to the total burnt gas.</li>
<li>Remember that the delayed queue indices has changed.</li>
</ol>
</li>
<li>Process the new local receipts and then the new incoming receipts
<ul>
<li>If the total burnt gas is less then the gas limit:
<ol>
<li>Process the receipt.</li>
<li>Add the new burnt gas to the total burnt gas.</li>
</ol>
</li>
<li>Else:
<ol>
<li>Store the receipt under the next available index.</li>
<li>Increment the next available index.</li>
<li>Remember that the delayed queue indices has changed.</li>
</ol>
</li>
</ul>
</li>
<li>If the delayed queue indices has changed, store the new indices to the state.</li>
</ol>
<h2><a class="header" href="#balance-checker" id="balance-checker">Balance checker</a></h2>
<p>Balance checker computes the total incoming balance and the total outgoing balance.</p>
<p>The total incoming balance consists of the following:</p>
<ul>
<li>Incoming validator rewards from validator accounts update.</li>
<li>Sum of the initial accounts balances for all affected accounts. We compute it using the snapshot of the initial state.</li>
<li>Incoming receipts balances. The prepaid fees and gas multiplied their gas prices with the attached balances from transfers and function calls.
Refunds are considered to be free of charge for fees, but still has attached deposits.</li>
<li>Balances for the processed delayed receipts.</li>
<li>Initial balances for the postponed receipts. Postponed receipts are receipts from the previous blocks that were processed, but were not executed.
They are action receipts with some expected incoming data. Usually for a callback on top of awaited promise.
When the expected data arrives later than the action receipt, then the action receipt is postponed.
Note, the data receipts are 0 cost, because they are completely prepaid when issued.</li>
</ul>
<p>The total outgoing balance consists of the following:</p>
<ul>
<li>Sum of the final accounts balance for all affected accounts.</li>
<li>Outgoing receipts balances.</li>
<li>New delayed receipts. Local and incoming receipts that were not processed this time.</li>
<li>Final balances for the postponed receipts.</li>
<li>Total rent paid by all affected accounts.</li>
<li>Total new validator rewards. It's computed from total gas burnt rewards.</li>
<li>Total balance burnt. In case the balance is burnt for some reason (e.g. account was deleted during the refund), it's accounted there.</li>
<li>Total balance slashed. In case a validator is slashed for some reason, the balance is account here.</li>
</ul>
<p>When you sum up incoming balances and outgoing balances, they should match.
If they don't match, we throw an error.</p>
<h1><a class="header" href="#bindings-specification" id="bindings-specification">Bindings Specification</a></h1>
<p>This is the low-level interface available to the smart contracts, it consists of the functions that the host (represented by
Wasmer inside near-vm-runner) exposes to the guest (the smart contract compiled to Wasm).</p>
<p>Due to Wasm restrictions the methods operate only with primitive types, like <code>u64</code>.</p>
<p>Also for all functions in the bindings specification the following is true:</p>
<ul>
<li>Method execution could result in <code>MemoryAccessViolation</code> error if one of the following happens:
<ul>
<li>The method causes host to read a piece of memory from the guest but it points outside the guest's memory;</li>
<li>The guest causes host to read from the register, but register id is invalid.</li>
</ul>
</li>
</ul>
<p>Execution of a bindings function call result in an error being generated. This error causes execution of the smart contract
to be terminated and the error message written into the logs of the transaction that caused the execution. Many bindings
functions can throw specialized error messages, but there is also a list of error messages that can be thrown by almost
any function:</p>
<ul>
<li><code>IntegerOverflow</code> -- happens when guest passes some data to the host but when host tries to apply arithmetic operation
on it it causes overflow or underflow;</li>
<li><code>GasExceeded</code> -- happens when operation performed by the guest causes more gas than the remaining prepaid gas;</li>
<li><code>GasLimitExceeded</code> -- happens when the execution uses more gas than allowed by the global limit imposed in the economics
config;</li>
<li><code>StorageError</code> -- happens when method fails to do some operation on the trie.</li>
</ul>
<p>The following binding methods cannot be invoked in a view call:</p>
<ul>
<li><code>signer_account_id</code></li>
<li><code>signer_account_pk</code></li>
<li><code>predecessor_account_id</code></li>
<li><code>attached_deposit</code></li>
<li><code>prepaid_gas</code></li>
<li><code>used_gas</code></li>
<li><code>promise_create</code></li>
<li><code>promise_then</code></li>
<li><code>promise_and</code></li>
<li><code>promise_batch_create</code></li>
<li><code>promise_batch_then</code></li>
<li><code>promise_batch_action_create_account</code></li>
<li><code>promise_batch_action_deploy_account</code></li>
<li><code>promise_batch_action_function_call</code></li>
<li><code>promise_batch_action_transfer</code></li>
<li><code>promise_batch_action_stake</code></li>
<li><code>promise_batch_action_add_key_with_full_access</code></li>
<li><code>promise_batch_action_add_key_with_function_call</code></li>
<li><code>promise_batch_action_delete_key</code></li>
<li><code>promise_batch_action_delete_account</code></li>
<li><code>promise_results_count</code></li>
<li><code>promise_result</code></li>
<li><code>promise_return</code></li>
</ul>
<p>If they are invoked the smart contract execution will panic with <code>ProhibitedInView(&lt;method name&gt;)</code>.</p>
<h1><a class="header" href="#registers-api" id="registers-api">Registers API</a></h1>
<p>Registers allow the host function to return the data into a buffer located inside the host oppose to the buffer
located on the client. A special operation can be used to copy the content of the buffer into the host. Memory pointers
can then be used to point either to the memory on the guest or the memory on the host, see below. Benefits:</p>
<ul>
<li>We can have functions that return values that are not necessarily used, e.g. inserting key-value into a trie can
also return the preempted old value, which might not be necessarily used. Previously, if we returned something we
would have to pass the blob from host into the guest, even if it is not used;</li>
<li>We can pass blobs of data between host functions without going through the guest, e.g. we can remove the value
from the storage and insert it into under a different key;</li>
<li>It makes API cleaner, because we don't need to pass <code>buffer_len</code> and <code>buffer_ptr</code> as arguments to other functions;</li>
<li>It allows merging certain functions together, see <code>storage_iter_next</code>;</li>
<li>This is consistent with other APIs that were created for high performance, e.g. allegedly Ewasm have implemented
SNARK-like computations in Wasm by exposing a bignum library through stack-like interface to the guest. The guest
can manipulate then with the stack of 256-bit numbers that is located on the host.</li>
</ul>
<h4><a class="header" href="#host--host-blob-passing" id="host--host-blob-passing">Host → host blob passing</a></h4>
<p>The registers can be used to pass the blobs between host functions. For any function that
takes a pair of arguments <code>*_len: u64, *_ptr: u64</code> this pair is pointing to a region of memory either on the guest or
the host:</p>
<ul>
<li>If <code>*_len != u64::MAX</code> it points to the memory on the guest;</li>
<li>If <code>*_len == u64::MAX</code> it points to the memory under the register <code>*_ptr</code> on the host.</li>
</ul>
<p>For example:
<code>storage_write(u64::MAX, 0, u64::MAX, 1, 2)</code> -- insert key-value into storage, where key is read from register 0,
value is read from register 1, and result is saved to register 2.</p>
<p>Note, if some function takes <code>register_id</code> then it means this function can copy some data into this register. If
<code>register_id == u64::MAX</code> then the copying does not happen. This allows some micro-optimizations in the future.</p>
<p>Note, we allow multiple registers on the host, identified with <code>u64</code> number. The guest does not have to use them in
order and can for instance save some blob in register <code>5000</code> and another value in register <code>1</code>.</p>
<h4><a class="header" href="#specification" id="specification">Specification</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>read_register(register_id: u64, ptr: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Writes the entire content from the register <code>register_id</code> into the memory of the guest starting with <code>ptr</code>.</p>
<h6><a class="header" href="#panics" id="panics">Panics</a></h6>
<ul>
<li>If the content extends outside the memory allocated to the guest. In Wasmer, it returns <code>MemoryAccessViolation</code> error message;</li>
<li>If <code>register_id</code> is pointing to unused register returns <code>InvalidRegisterId</code> error message.</li>
</ul>
<h6><a class="header" href="#undefined-behavior" id="undefined-behavior">Undefined Behavior</a></h6>
<ul>
<li>If the content of register extends outside the preallocated memory on the host side, or the pointer points to a
wrong location this function will overwrite memory that it is not supposed to overwrite causing an undefined behavior.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>register_len(register_id: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>Returns the size of the blob stored in the given register.</p>
<h6><a class="header" href="#normal-operation" id="normal-operation">Normal operation</a></h6>
<ul>
<li>If register is used, then returns the size, which can potentially be zero;</li>
<li>If register is not used, returns <code>u64::MAX</code></li>
</ul>
<h1><a class="header" href="#trie-api" id="trie-api">Trie API</a></h1>
<p>Here we provide a specification of trie API. After this NEP is merged, the cases where our current implementation does
not follow the specification are considered to be bugs that need to be fixed.</p>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>storage_write(key_len: u64, key_ptr: u64, value_len: u64, value_ptr: u64, register_id: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>Writes key-value into storage.</p>
<h6><a class="header" href="#normal-operation-1" id="normal-operation-1">Normal operation</a></h6>
<ul>
<li>If key is not in use it inserts the key-value pair and does not modify the register;</li>
<li>If key is in use it inserts the key-value and copies the old value into the <code>register_id</code>.</li>
</ul>
<h6><a class="header" href="#returns" id="returns">Returns</a></h6>
<ul>
<li>If key was not used returns <code>0</code>;</li>
<li>If key was used returns <code>1</code>.</li>
</ul>
<h6><a class="header" href="#panics-1" id="panics-1">Panics</a></h6>
<ul>
<li>If <code>key_len + key_ptr</code> or <code>value_len + value_ptr</code> exceeds the memory container or points to an unused register it panics
with <code>MemoryAccessViolation</code>. (When we say that something panics with the given error we mean that we use Wasmer API to
create this error and terminate the execution of VM. For mocks of the host that would only cause a non-name panic.)</li>
<li>If returning the preempted value into the registers exceed the memory container it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<h6><a class="header" href="#current-bugs" id="current-bugs">Current bugs</a></h6>
<ul>
<li><code>External::storage_set</code> trait can return an error which is then converted to a generic non-descriptive
<code>StorageUpdateError</code>, <a href="https://github.com/nearprotocol/nearcore/blob/942bd7bdbba5fb3403e5c2f1ee3c08963947d0c6/runtime/wasm/src/runtime.rs#L210">here</a>
however the actual implementation does not return error at all, <a href="https://github.com/nearprotocol/nearcore/blob/4773873b3cd680936bf206cebd56bdc3701ddca9/runtime/runtime/src/ext.rs#L95">see</a>;</li>
<li>Does not return into the registers.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>storage_read(key_len: u64, key_ptr: u64, register_id: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>Reads the value stored under the given key.</p>
<h6><a class="header" href="#normal-operation-2" id="normal-operation-2">Normal operation</a></h6>
<ul>
<li>If key is used copies the content of the value into the <code>register_id</code>, even if the content is zero bytes;</li>
<li>If key is not present then does not modify the register.</li>
</ul>
<h6><a class="header" href="#returns-1" id="returns-1">Returns</a></h6>
<ul>
<li>If key was not present returns <code>0</code>;</li>
<li>If key was present returns <code>1</code>.</li>
</ul>
<h6><a class="header" href="#panics-2" id="panics-2">Panics</a></h6>
<ul>
<li>If <code>key_len + key_ptr</code> exceeds the memory container or points to an unused register it panics with <code>MemoryAccessViolation</code>;</li>
<li>If returning the preempted value into the registers exceed the memory container it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<h6><a class="header" href="#current-bugs-1" id="current-bugs-1">Current bugs</a></h6>
<ul>
<li>This function currently does not exist.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>storage_remove(key_len: u64, key_ptr: u64, register_id: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>Removes the value stored under the given key.</p>
<h6><a class="header" href="#normal-operation-3" id="normal-operation-3">Normal operation</a></h6>
<p>Very similar to <code>storage_read</code>:</p>
<ul>
<li>If key is used, removes the key-value from the trie and copies the content of the value into the <code>register_id</code>, even if the content is zero bytes.</li>
<li>If key is not present then does not modify the register.</li>
</ul>
<h6><a class="header" href="#returns-2" id="returns-2">Returns</a></h6>
<ul>
<li>If key was not present returns <code>0</code>;</li>
<li>If key was present returns <code>1</code>.</li>
</ul>
<h6><a class="header" href="#panics-3" id="panics-3">Panics</a></h6>
<ul>
<li>If <code>key_len + key_ptr</code> exceeds the memory container or points to an unused register it panics with <code>MemoryAccessViolation</code>;</li>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
<li>If returning the preempted value into the registers exceed the memory container it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<h6><a class="header" href="#current-bugs-2" id="current-bugs-2">Current bugs</a></h6>
<ul>
<li>Does not return into the registers.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>storage_has_key(key_len: u64, key_ptr: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>Checks if there is a key-value pair.</p>
<h6><a class="header" href="#normal-operation-4" id="normal-operation-4">Normal operation</a></h6>
<ul>
<li>If key is used returns <code>1</code>, even if the value is zero bytes;</li>
<li>Otherwise returns <code>0</code>.</li>
</ul>
<h6><a class="header" href="#panics-4" id="panics-4">Panics</a></h6>
<ul>
<li>If <code>key_len + key_ptr</code> exceeds the memory container it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>storage_iter_prefix(prefix_len: u64, prefix_ptr: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>DEPRECATED, calling it will result result in <code>HostError::Deprecated</code> error.
Creates an iterator object inside the host.
Returns the identifier that uniquely differentiates the given iterator from other iterators that can be simultaneously
created.</p>
<h6><a class="header" href="#normal-operation-5" id="normal-operation-5">Normal operation</a></h6>
<ul>
<li>It iterates over the keys that have the provided prefix. The order of iteration is defined by the lexicographic
order of the bytes in the keys. If there are no keys, it creates an empty iterator, see below on empty iterators;</li>
</ul>
<h6><a class="header" href="#panics-5" id="panics-5">Panics</a></h6>
<ul>
<li>If <code>prefix_len + prefix_ptr</code> exceeds the memory container it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>storage_iter_range(start_len: u64, start_ptr: u64, end_len: u64, end_ptr: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>DEPRECATED, calling it will result result in <code>HostError::Deprecated</code> error.
Similarly to <code>storage_iter_prefix</code>
creates an iterator object inside the host.</p>
<h6><a class="header" href="#normal-operation-6" id="normal-operation-6">Normal operation</a></h6>
<p>Unless lexicographically <code>start &lt; end</code>, it creates an empty iterator.
Iterates over all key-values such that keys are between <code>start</code> and <code>end</code>, where <code>start</code> is inclusive and <code>end</code> is exclusive.</p>
<p>Note, this definition allows for <code>start</code> or <code>end</code> keys to not actually exist on the given trie.</p>
<h6><a class="header" href="#panics-6" id="panics-6">Panics:</a></h6>
<ul>
<li>If <code>start_len + start_ptr</code> or <code>end_len + end_ptr</code> exceeds the memory container or points to an unused register it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>storage_iter_next(iterator_id: u64, key_register_id: u64, value_register_id: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>DEPRECATED, calling it will result result in <code>HostError::Deprecated</code> error.
Advances iterator and saves the next key and value in the register.</p>
<h6><a class="header" href="#normal-operation-7" id="normal-operation-7">Normal operation</a></h6>
<ul>
<li>If iterator is not empty (after calling next it points to a key-value), copies the key into <code>key_register_id</code> and value into <code>value_register_id</code> and returns <code>1</code>;</li>
<li>If iterator is empty returns <code>0</code>.</li>
</ul>
<p>This allows us to iterate over the keys that have zero bytes stored in values.</p>
<h6><a class="header" href="#panics-7" id="panics-7">Panics</a></h6>
<ul>
<li>If <code>key_register_id == value_register_id</code> panics with <code>MemoryAccessViolation</code>;</li>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
<li>If <code>iterator_id</code> does not correspond to an existing iterator panics with <code>InvalidIteratorId</code></li>
<li>If between the creation of the iterator and calling <code>storage_iter_next</code> any modification to storage was done through
<code>storage_write</code> or <code>storage_remove</code> the iterator is invalidated and the error message is <code>IteratorWasInvalidated</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-3" id="current-bugs-3">Current bugs</a></h6>
<ul>
<li>Not implemented, currently we have <code>storage_iter_next</code> and <code>data_read</code> + <code>DATA_TYPE_STORAGE_ITER</code> that together fulfill
the purpose, but have unspecified behavior.</li>
</ul>
<h1><a class="header" href="#promises-api" id="promises-api">Promises API</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_create(account_id_len: u64,
               account_id_ptr: u64,
               method_name_len: u64,
               method_name_ptr: u64,
               arguments_len: u64,
               arguments_ptr: u64,
               amount_ptr: u64,
               gas: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>Creates a promise that will execute a method on account with given arguments and attaches the given amount.
<code>amount_ptr</code> point to slices of bytes representing <code>u128</code>.</p>
<h6><a class="header" href="#panics-8" id="panics-8">Panics</a></h6>
<ul>
<li>If <code>account_id_len + account_id_ptr</code> or <code>method_name_len + method_name_ptr</code> or <code>arguments_len + arguments_ptr</code>
or <code>amount_ptr + 16</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#returns-3" id="returns-3">Returns</a></h6>
<ul>
<li>Index of the new promise that uniquely identifies it within the current execution of the method.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_then(promise_idx: u64,
             account_id_len: u64,
             account_id_ptr: u64,
             method_name_len: u64,
             method_name_ptr: u64,
             arguments_len: u64,
             arguments_ptr: u64,
             amount_ptr: u64,
             gas: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>Attaches the callback that is executed after promise pointed by <code>promise_idx</code> is complete.</p>
<h6><a class="header" href="#panics-9" id="panics-9">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If <code>account_id_len + account_id_ptr</code> or <code>method_name_len + method_name_ptr</code> or <code>arguments_len + arguments_ptr</code>
or <code>amount_ptr + 16</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#returns-4" id="returns-4">Returns</a></h6>
<ul>
<li>Index of the new promise that uniquely identifies it within the current execution of the method.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_and(promise_idx_ptr: u64, promise_idx_count: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>Creates a new promise which completes when time all promises passed as arguments complete. Cannot be used with registers.
<code>promise_idx_ptr</code> points to an array of <code>u64</code> elements, with <code>promise_idx_count</code> denoting the number of elements.
The array contains indices of promises that need to be waited on jointly.</p>
<h6><a class="header" href="#panics-10" id="panics-10">Panics</a></h6>
<ul>
<li>If <code>promise_ids_ptr + 8 * promise_idx_count</code> extend outside the guest memory with <code>MemoryAccessViolation</code>;</li>
<li>If any of the promises in the array do not correspond to existing promises panics with <code>InvalidPromiseIndex</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#returns-5" id="returns-5">Returns</a></h6>
<ul>
<li>Index of the new promise that uniquely identifies it within the current execution of the method.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_results_count() -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>If the current function is invoked by a callback we can access the execution results of the promises that
caused the callback. This function returns the number of complete and incomplete callbacks.</p>
<p>Note, we are only going to have incomplete callbacks once we have <code>promise_or</code> combinator.</p>
<h6><a class="header" href="#normal-execution" id="normal-execution">Normal execution</a></h6>
<ul>
<li>If there is only one callback <code>promise_results_count()</code> returns <code>1</code>;</li>
<li>If there are multiple callbacks (e.g. created through <code>promise_and</code>) <code>promise_results_count()</code> returns their number.</li>
<li>If the function was called not through the callback <code>promise_results_count()</code> returns <code>0</code>.</li>
</ul>
<h6><a class="header" href="#panics-11" id="panics-11">Panics</a></h6>
<ul>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_result(result_idx: u64, register_id: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>If the current function is invoked by a callback we can access the execution results of the promises that
caused the callback. This function returns the result in blob format and places it into the register.</p>
<h6><a class="header" href="#normal-execution-1" id="normal-execution-1">Normal execution</a></h6>
<ul>
<li>If promise result is complete and successful copies its blob into the register;</li>
<li>If promise result is complete and failed or incomplete keeps register unused;</li>
</ul>
<h6><a class="header" href="#returns-6" id="returns-6">Returns</a></h6>
<ul>
<li>If promise result is not complete returns <code>0</code>;</li>
<li>If promise result is complete and successful returns <code>1</code>;</li>
<li>If promise result is complete and failed returns <code>2</code>.</li>
</ul>
<h6><a class="header" href="#panics-12" id="panics-12">Panics</a></h6>
<ul>
<li>If <code>result_idx</code> does not correspond to an existing result panics with <code>InvalidResultIndex</code>.</li>
<li>If copying the blob exhausts the memory limit it panics with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-4" id="current-bugs-4">Current bugs</a></h6>
<ul>
<li>We currently have two separate functions to check for result completion and copy it.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_return(promise_idx: u64)
<span class="boring">}
</span></code></pre></pre>
<p>When promise <code>promise_idx</code> finishes executing its result is considered to be the result of the current function.</p>
<h6><a class="header" href="#panics-13" id="panics-13">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-5" id="current-bugs-5">Current bugs</a></h6>
<ul>
<li>The current name <code>return_promise</code> is inconsistent with the naming convention of Promise API.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_batch_create(account_id_len: u64, account_id_ptr: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>Creates a new promise towards given <code>account_id</code> without any actions attached to it.</p>
<h6><a class="header" href="#panics-14" id="panics-14">Panics</a></h6>
<ul>
<li>If <code>account_id_len + account_id_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#returns-7" id="returns-7">Returns</a></h6>
<ul>
<li>Index of the new promise that uniquely identifies it within the current execution of the method.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_batch_then(promise_idx: u64, account_id_len: u64, account_id_ptr: u64) -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>Attaches a new empty promise that is executed after promise pointed by <code>promise_idx</code> is complete.</p>
<h6><a class="header" href="#panics-15" id="panics-15">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If <code>account_id_len + account_id_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#returns-8" id="returns-8">Returns</a></h6>
<ul>
<li>Index of the new promise that uniquely identifies it within the current execution of the method.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_batch_action_create_account(promise_idx: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Appends <code>CreateAccount</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R48</p>
<h6><a class="header" href="#panics-16" id="panics-16">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_batch_action_deploy_contract(promise_idx: u64, code_len: u64, code_ptr: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Appends <code>DeployContract</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R49</p>
<h6><a class="header" href="#panics-17" id="panics-17">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If <code>code_len + code_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_batch_action_function_call(promise_idx: u64,
                                   method_name_len: u64,
                                   method_name_ptr: u64,
                                   arguments_len: u64,
                                   arguments_ptr: u64,
                                   amount_ptr: u64,
                                   gas: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Appends <code>FunctionCall</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R50</p>
<p><em>NOTE: Calling <code>promise_batch_create</code> and then <code>promise_batch_action_function_call</code> will produce the same promise as calling <code>promise_create</code> directly.</em></p>
<h6><a class="header" href="#panics-18" id="panics-18">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If <code>account_id_len + account_id_ptr</code> or <code>method_name_len + method_name_ptr</code> or <code>arguments_len + arguments_ptr</code>
or <code>amount_ptr + 16</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_batch_action_transfer(promise_idx: u64, amount_ptr: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Appends <code>Transfer</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R51</p>
<h6><a class="header" href="#panics-19" id="panics-19">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If <code>amount_ptr + 16</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_batch_action_stake(promise_idx: u64,
                           amount_ptr: u64,
                           bls_public_key_len: u64,
                           bls_public_key_ptr: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Appends <code>Stake</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R52</p>
<h6><a class="header" href="#panics-20" id="panics-20">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If the given BLS public key is not a valid BLS public key (e.g. wrong length) <code>InvalidPublicKey</code>.</li>
<li>If <code>amount_ptr + 16</code> or <code>bls_public_key_len + bls_public_key_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_batch_action_add_key_with_full_access(promise_idx: u64,
                                              public_key_len: u64,
                                              public_key_ptr: u64,
                                              nonce: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Appends <code>AddKey</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R54
The access key will have <code>FullAccess</code> permission, details: https://github.com/nearprotocol/NEPs/blob/master/text/0005-access-keys.md#guide-level-explanation</p>
<h6><a class="header" href="#panics-21" id="panics-21">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If the given public key is not a valid public key (e.g. wrong length) <code>InvalidPublicKey</code>.</li>
<li>If <code>public_key_len + public_key_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_batch_action_add_key_with_function_call(promise_idx: u64,
                                                public_key_len: u64,
                                                public_key_ptr: u64,
                                                nonce: u64,
                                                allowance_ptr: u64,
                                                receiver_id_len: u64,
                                                receiver_id_ptr: u64,
                                                method_names_len: u64,
                                                method_names_ptr: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Appends <code>AddKey</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-156752ec7d78e7b85b8c7de4a19cbd4R54
The access key will have <code>FunctionCall</code> permission, details: https://github.com/nearprotocol/NEPs/blob/master/text/0005-access-keys.md#guide-level-explanation</p>
<ul>
<li>If the <code>allowance</code> value (not the pointer) is <code>0</code>, the allowance is set to <code>None</code> (which means unlimited allowance). And positive value represents a <code>Some(...)</code> allowance.</li>
<li>Given <code>method_names</code> is a <code>utf-8</code> string with <code>,</code> used as a separator. The vm will split the given string into a vector of strings.</li>
</ul>
<h6><a class="header" href="#panics-22" id="panics-22">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If the given public key is not a valid public key (e.g. wrong length) <code>InvalidPublicKey</code>.</li>
<li>if <code>method_names</code> is not a valid <code>utf-8</code> string, fails with <code>BadUTF8</code>.</li>
<li>If <code>public_key_len + public_key_ptr</code>, <code>allowance_ptr + 16</code>, <code>receiver_id_len + receiver_id_ptr</code> or
<code>method_names_len + method_names_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_batch_action_delete_key(promise_idx: u64,
                                public_key_len: u64,
                                public_key_ptr: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Appends <code>DeleteKey</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Details for the action: https://github.com/nearprotocol/NEPs/pull/8/files#diff-15b6752ec7d78e7b85b8c7de4a19cbd4R55</p>
<h6><a class="header" href="#panics-23" id="panics-23">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If the given public key is not a valid public key (e.g. wrong length) <code>InvalidPublicKey</code>.</li>
<li>If <code>public_key_len + public_key_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>promise_batch_action_delete_account(promise_idx: u64,
                                    beneficiary_id_len: u64,
                                    beneficiary_id_ptr: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Appends <code>DeleteAccount</code> action to the batch of actions for the given promise pointed by <code>promise_idx</code>.
Action is used to delete an account. It can be performed on a newly created account, on your own account or an account with
insufficient funds to pay rent. Takes <code>beneficiary_id</code> to indicate where to send the remaining funds.</p>
<h6><a class="header" href="#panics-24" id="panics-24">Panics</a></h6>
<ul>
<li>If <code>promise_idx</code> does not correspond to an existing promise panics with <code>InvalidPromiseIndex</code>.</li>
<li>If the promise pointed by the <code>promise_idx</code> is an ephemeral promise created by <code>promise_and</code>.</li>
<li>If <code>beneficiary_id_len + beneficiary_id_ptr</code> points outside the memory of the guest or host, with <code>MemoryAccessViolation</code>.</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h1><a class="header" href="#context-api" id="context-api">Context API</a></h1>
<p>Context API mostly provides read-only functions that access current information about the blockchain, the accounts
(that originally initiated the chain of cross-contract calls, the immediate contract that called the current one, the account of the current contract),
other important information like storage usage.</p>
<p>Many of the below functions are currently implemented through <code>data_read</code> which allows to read generic context data.
However, there is no reason to have <code>data_read</code> instead of the specific functions:</p>
<ul>
<li><code>data_read</code> does not solve forward compatibility. If later we want to add another context function, e.g. <code>executed_operations</code>
we can just declare it as a new function, instead of encoding it as <code>DATA_TYPE_EXECUTED_OPERATIONS = 42</code> which is passed
as the first argument to <code>data_read</code>;</li>
<li><code>data_read</code> does not help with renaming. If later we decide to rename <code>signer_account_id</code> to <code>originator_id</code> then one could
argue that contracts that rely on <code>data_read</code> would not break, while contracts relying on <code>signer_account_id()</code> would. However
the name change often means the change of the semantics, which means the contracts using this function are no longer safe to
execute anyway.</li>
</ul>
<p>However there is one reason to not have <code>data_read</code> -- it makes <code>API</code> more human-like which is a general direction Wasm APIs, like WASI are moving towards to.</p>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>current_account_id(register_id: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Saves the account id of the current contract that we execute into the register.</p>
<h6><a class="header" href="#panics-25" id="panics-25">Panics</a></h6>
<ul>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>signer_account_id(register_id: u64)
<span class="boring">}
</span></code></pre></pre>
<p>All contract calls are a result of some transaction that was signed by some account using
some access key and submitted into a memory pool (either through the wallet using RPC or by a node itself). This function returns the id of that account.</p>
<h6><a class="header" href="#normal-operation-8" id="normal-operation-8">Normal operation</a></h6>
<ul>
<li>Saves the bytes of the signer account id into the register.</li>
</ul>
<h6><a class="header" href="#panics-26" id="panics-26">Panics</a></h6>
<ul>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-6" id="current-bugs-6">Current bugs</a></h6>
<ul>
<li>Currently we conflate <code>originator_id</code> and <code>sender_id</code> in our code base.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>signer_account_pk(register_id: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Saves the public key fo the access key that was used by the signer into the register.
In rare situations smart contract might want to know the exact access key that was used to send the original transaction,
e.g. to increase the allowance or manipulate with the public key.</p>
<h6><a class="header" href="#panics-27" id="panics-27">Panics</a></h6>
<ul>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-7" id="current-bugs-7">Current bugs</a></h6>
<ul>
<li>Not implemented.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>predecessor_account_id(register_id: u64)
<span class="boring">}
</span></code></pre></pre>
<p>All contract calls are a result of a receipt, this receipt might be created by a transaction
that does function invocation on the contract or another contract as a result of cross-contract call.</p>
<h6><a class="header" href="#normal-operation-9" id="normal-operation-9">Normal operation</a></h6>
<ul>
<li>Saves the bytes of the predecessor account id into the register.</li>
</ul>
<h6><a class="header" href="#panics-28" id="panics-28">Panics</a></h6>
<ul>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-8" id="current-bugs-8">Current bugs</a></h6>
<ul>
<li>Not implemented.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>input(register_id: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Reads input to the contract call into the register. Input is expected to be in JSON-format.</p>
<h6><a class="header" href="#normal-operation-10" id="normal-operation-10">Normal operation</a></h6>
<ul>
<li>If input is provided saves the bytes (potentially zero) of input into register.</li>
<li>If input is not provided does not modify the register.</li>
</ul>
<h6><a class="header" href="#returns-9" id="returns-9">Returns</a></h6>
<ul>
<li>If input was not provided returns <code>0</code>;</li>
<li>If input was provided returns <code>1</code>; If input is zero bytes returns <code>1</code>, too.</li>
</ul>
<h6><a class="header" href="#panics-29" id="panics-29">Panics</a></h6>
<ul>
<li>If the registers exceed the memory limit panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<h6><a class="header" href="#current-bugs-9" id="current-bugs-9">Current bugs</a></h6>
<ul>
<li>Implemented as part of <code>data_read</code>. However there is no reason to have one unified function, like <code>data_read</code> that can
be used to read all</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>block_index() -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>Returns the current block index.</p>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>storage_usage() -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<p>Returns the number of bytes used by the contract if it was saved to the trie as of the
invocation. This includes:</p>
<ul>
<li>The data written with <code>storage_*</code> functions during current and previous execution;</li>
<li>The bytes needed to store the account protobuf and the access keys of the given account.</li>
</ul>
<h1><a class="header" href="#economics-api" id="economics-api">Economics API</a></h1>
<p>Accounts own certain balance; and each transaction and each receipt have certain amount of balance and prepaid gas
attached to them.
During the contract execution, the contract has access to the following <code>u128</code> values:</p>
<ul>
<li><code>account_balance</code> -- the balance attached to the given account. This includes the <code>attached_deposit</code> that was attached
to the transaction;</li>
<li><code>attached_deposit</code> -- the balance that was attached to the call that will be immediately deposited before
the contract execution starts;</li>
<li><code>prepaid_gas</code> -- the tokens attached to the call that can be used to pay for the gas;</li>
<li><code>used_gas</code> -- the gas that was already burnt during the contract execution and attached to promises (cannot exceed <code>prepaid_gas</code>);</li>
</ul>
<p>If contract execution fails <code>prepaid_gas - used_gas</code> is refunded back to <code>signer_account_id</code> and <code>attached_deposit</code>
is refunded back to <code>predecessor_account_id</code>.</p>
<p>The following spec is the same for all functions:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>account_balance(balance_ptr: u64)
attached_deposit(balance_ptr: u64)

<span class="boring">}
</span></code></pre></pre>
<p>-- writes the value into the <code>u128</code> variable pointed by <code>balance_ptr</code>.</p>
<h6><a class="header" href="#panics-30" id="panics-30">Panics</a></h6>
<ul>
<li>If <code>balance_ptr + 16</code> points outside the memory of the guest with <code>MemoryAccessViolation</code>;</li>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h6><a class="header" href="#current-bugs-10" id="current-bugs-10">Current bugs</a></h6>
<ul>
<li>Use a different name;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>prepaid_gas() -&gt; u64
used_gas() -&gt; u64
<span class="boring">}
</span></code></pre></pre>
<h6><a class="header" href="#panics-31" id="panics-31">Panics</a></h6>
<ul>
<li>If called in a view function panics with <code>ProhibitedInView</code>.</li>
</ul>
<h1><a class="header" href="#math-api" id="math-api">Math API</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>random_seed(register_id: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Returns random seed that can be used for pseudo-random number generation in deterministic way.</p>
<h6><a class="header" href="#panics-32" id="panics-32">Panics</a></h6>
<ul>
<li>If the size of the registers exceed the set limit <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>sha256(value_len: u64, value_ptr: u64, register_id: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Hashes the random sequence of bytes using sha256 and returns it into <code>register_id</code>.</p>
<h6><a class="header" href="#panics-33" id="panics-33">Panics</a></h6>
<ul>
<li>If <code>value_len + value_ptr</code> points outside the memory or the registers use more memory than the limit with <code>MemoryAccessViolation</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>keccak256(value_len: u64, value_ptr: u64, register_id: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Hashes the random sequence of bytes using keccak256 and returns it into <code>register_id</code>.</p>
<h6><a class="header" href="#panics-34" id="panics-34">Panics</a></h6>
<ul>
<li>If <code>value_len + value_ptr</code> points outside the memory or the registers use more memory than the limit with <code>MemoryAccessViolation</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>keccak512(value_len: u64, value_ptr: u64, register_id: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Hashes the random sequence of bytes using keccak512 and returns it into <code>register_id</code>.</p>
<h6><a class="header" href="#panics-35" id="panics-35">Panics</a></h6>
<ul>
<li>If <code>value_len + value_ptr</code> points outside the memory or the registers use more memory than the limit with <code>MemoryAccessViolation</code>.</li>
</ul>
<h1><a class="header" href="#miscellaneous-api" id="miscellaneous-api">Miscellaneous API</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>value_return(value_len: u64, value_ptr: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Sets the blob of data as the return value of the contract.</p>
<h6><a class="header" href="#panics-36" id="panics-36">Panics</a></h6>
<ul>
<li>If <code>value_len + value_ptr</code> exceeds the memory container or points to an unused register it panics with <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>panic()
<span class="boring">}
</span></code></pre></pre>
<p>Terminates the execution of the program with panic <code>GuestPanic(&quot;explicit guest panic&quot;)</code>.</p>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>panic_utf8(len: u64, ptr: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Terminates the execution of the program with panic <code>GuestPanic(s)</code>, where <code>s</code> is the given UTF-8 encoded string.</p>
<h6><a class="header" href="#normal-behavior" id="normal-behavior">Normal behavior</a></h6>
<p>If <code>len == u64::MAX</code> then treats the string as null-terminated with character <code>'\0'</code>;</p>
<h6><a class="header" href="#panics-37" id="panics-37">Panics</a></h6>
<ul>
<li>If string extends outside the memory of the guest with <code>MemoryAccessViolation</code>;</li>
<li>If string is not UTF-8 returns <code>BadUtf8</code>.</li>
<li>If string length without null-termination symbol is larger than <code>config.max_log_len</code> returns <code>BadUtf8</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>log_utf8(len: u64, ptr: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Logs the UTF-8 encoded string.</p>
<h6><a class="header" href="#normal-behavior-1" id="normal-behavior-1">Normal behavior</a></h6>
<p>If <code>len == u64::MAX</code> then treats the string as null-terminated with character <code>'\0'</code>;</p>
<h6><a class="header" href="#panics-38" id="panics-38">Panics</a></h6>
<ul>
<li>If string extends outside the memory of the guest with <code>MemoryAccessViolation</code>;</li>
<li>If string is not UTF-8 returns <code>BadUtf8</code>.</li>
<li>If string length without null-termination symbol is larger than <code>config.max_log_len</code> returns <code>BadUtf8</code>.</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>log_utf16(len: u64, ptr: u64)
<span class="boring">}
</span></code></pre></pre>
<p>Logs the UTF-16 encoded string. <code>len</code> is the number of bytes in the string.
See https://stackoverflow.com/a/5923961 that explains that null termination is not defined through encoding.</p>
<h6><a class="header" href="#normal-behavior-2" id="normal-behavior-2">Normal behavior</a></h6>
<p>If <code>len == u64::MAX</code> then treats the string as null-terminated with two-byte sequence of <code>0x00 0x00</code>.</p>
<h6><a class="header" href="#panics-39" id="panics-39">Panics</a></h6>
<ul>
<li>If string extends outside the memory of the guest with <code>MemoryAccessViolation</code>;</li>
</ul>
<hr />
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>abort(msg_ptr: u32, filename_ptr: u32, line: u32, col: u32)
<span class="boring">}
</span></code></pre></pre>
<p>Special import kept for compatibility with AssemblyScript contracts. Not called by smart contracts directly, but instead
called by the code generated by AssemblyScript.</p>
<h1><a class="header" href="#future-improvements" id="future-improvements">Future Improvements</a></h1>
<p>In the future we can have some of the registers to be on the guest.
For instance a guest can tell the host that it has some pre-allocated memory that it wants to be used for the register,
e.g.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>set_guest_register(register_id: u64, register_ptr: u64, max_register_size: u64)
<span class="boring">}
</span></code></pre></pre>
<p>will assign <code>register_id</code> to a span of memory on the guest. Host then would also know the size of that buffer on guest
and can throw a panic if there is an attempted copying that exceeds the guest register size.</p>
<h1><a class="header" href="#genesisconfig" id="genesisconfig">GenesisConfig</a></h1>
<h2><a class="header" href="#protocol_version" id="protocol_version">protocol_version</a></h2>
<p><em>type: u32</em></p>
<p>Protocol version that this genesis works with.</p>
<h2><a class="header" href="#genesis_time" id="genesis_time">genesis_time</a></h2>
<p><em>type: DateTime</em></p>
<p>Official time of blockchain start.</p>
<h2><a class="header" href="#chain_id" id="chain_id">chain_id</a></h2>
<p><em>type: String</em></p>
<p>ID of the blockchain. This must be unique for every blockchain.
If your testnet blockchains do not have unique chain IDs, you will have a bad time.</p>
<h2><a class="header" href="#num_block_producers" id="num_block_producers">num_block_producers</a></h2>
<p><em>type: u32</em></p>
<p>Number of block producer seats at genesis.</p>
<h2><a class="header" href="#block_producers_per_shard" id="block_producers_per_shard">block_producers_per_shard</a></h2>
<p><em>type: [ValidatorId]</em></p>
<p>Defines number of shards and number of validators per each shard at genesis.</p>
<h2><a class="header" href="#avg_fisherman_per_shard" id="avg_fisherman_per_shard">avg_fisherman_per_shard</a></h2>
<p><em>type: [ValidatorId]</em></p>
<p>Expected number of fisherman per shard.</p>
<h2><a class="header" href="#dynamic_resharding" id="dynamic_resharding">dynamic_resharding</a></h2>
<p><em>type: bool</em></p>
<p>Enable dynamic re-sharding.</p>
<h2><a class="header" href="#epoch_length" id="epoch_length">epoch_length</a></h2>
<p><em>type: BlockIndex,</em></p>
<p>Epoch length counted in blocks.</p>
<h2><a class="header" href="#gas_limit" id="gas_limit">gas_limit</a></h2>
<p><em>type: Gas,</em></p>
<p>Initial gas limit for a block</p>
<h2><a class="header" href="#gas_price-1" id="gas_price-1">gas_price</a></h2>
<p><em>type: Balance,</em></p>
<p>Initial gas price</p>
<h2><a class="header" href="#block_producer_kickout_threshold" id="block_producer_kickout_threshold">block_producer_kickout_threshold</a></h2>
<p><em>type: u8</em></p>
<p>Criterion for kicking out block producers (this is a number between 0 and 100)</p>
<h2><a class="header" href="#chunk_producer_kickout_threshold" id="chunk_producer_kickout_threshold">chunk_producer_kickout_threshold</a></h2>
<p><em>type: u8</em></p>
<p>Criterion for kicking out chunk producers (this is a number between 0 and 100)</p>
<h2><a class="header" href="#gas_price_adjustment_rate" id="gas_price_adjustment_rate">gas_price_adjustment_rate</a></h2>
<p><em>type: u8</em></p>
<p>Gas price adjustment rate</p>
<h2><a class="header" href="#runtime_config" id="runtime_config">runtime_config</a></h2>
<p><em>type: <a href="GenesisConfig/RuntimeConfig.html">RuntimeConfig</a></em></p>
<p>Runtime configuration (mostly economics constants).</p>
<h2><a class="header" href="#validators-1" id="validators-1">validators</a></h2>
<p><em>type: [AccountInfo]</em></p>
<p>List of initial validators.</p>
<h2><a class="header" href="#records" id="records">records</a></h2>
<p><em>type: [StateRecord]</em></p>
<p>Records in storage at genesis (get split into shards at genesis creation).</p>
<h2><a class="header" href="#transaction_validity_period" id="transaction_validity_period">transaction_validity_period</a></h2>
<p><em>type: u64</em></p>
<p>Number of blocks for which a given transaction is valid</p>
<h2><a class="header" href="#developer_reward_percentage" id="developer_reward_percentage">developer_reward_percentage</a></h2>
<p><em>type: u8</em></p>
<p>Developer reward percentage (this is a number between 0 and 100)</p>
<h2><a class="header" href="#protocol_reward_percentage" id="protocol_reward_percentage">protocol_reward_percentage</a></h2>
<p><em>type: u8</em></p>
<p>Protocol treasury percentage (this is a number between 0 and 100)</p>
<h2><a class="header" href="#max_inflation_rate" id="max_inflation_rate">max_inflation_rate</a></h2>
<p><em>type: u8</em></p>
<p>Maximum inflation on the total supply every epoch (this is a number between 0 and 100)</p>
<h2><a class="header" href="#total_supply" id="total_supply">total_supply</a></h2>
<p><em>type: Balance</em></p>
<p>Total supply of tokens at genesis.</p>
<h2><a class="header" href="#num_blocks_per_year" id="num_blocks_per_year">num_blocks_per_year</a></h2>
<p><em>type: u64</em></p>
<p>Expected number of blocks per year</p>
<h2><a class="header" href="#protocol_treasury_account" id="protocol_treasury_account">protocol_treasury_account</a></h2>
<p><em>type: AccountId</em></p>
<p>Protocol treasury account</p>
<h2><a class="header" href="#protocol-economics" id="protocol-economics">protocol economics</a></h2>
<blockquote>
<p>For the specific economic specs, refer to <a href="GenesisConfig/../Economics/README.html">Economics Section</a>.</p>
</blockquote>
<h2><a class="header" href="#runtimeconfig" id="runtimeconfig">RuntimeConfig</a></h2>
<p>The structure that holds the parameters of the runtime, mostly economics.</p>
<h3><a class="header" href="#storage_cost_byte_per_block" id="storage_cost_byte_per_block">storage_cost_byte_per_block</a></h3>
<p><em>type: Balance</em></p>
<p>The cost to store one byte of storage per block.</p>
<h3><a class="header" href="#storage_cost_byte_per_block-1" id="storage_cost_byte_per_block-1">storage_cost_byte_per_block</a></h3>
<p><em>type: Balance</em></p>
<p>Costs of different actions that need to be performed when sending and processing transaction
and receipts.</p>
<h3><a class="header" href="#poke_threshold" id="poke_threshold">poke_threshold</a></h3>
<p><em>type: BlockIndex</em></p>
<p>The minimum number of blocks of storage rent an account has to maintain to prevent forced deletion.</p>
<h3><a class="header" href="#transaction_costs" id="transaction_costs">transaction_costs</a></h3>
<p><em>type: <a href="GenesisConfig/RuntimeFeeConfig.html">RuntimeFeesConfig</a></em></p>
<p>Costs of different actions that need to be performed when sending and processing transaction and receipts.</p>
<h3><a class="header" href="#wasm_config" id="wasm_config">wasm_config</a></h3>
<p><em>type: <a href="GenesisConfig/VMConfig.html">VMConfig</a>,</em></p>
<p>Config of wasm operations.</p>
<h3><a class="header" href="#account_length_baseline_cost_per_block" id="account_length_baseline_cost_per_block">account_length_baseline_cost_per_block</a></h3>
<p><em>type: Balance</em></p>
<p>The baseline cost to store account_id of short length per block.
The original formula in NEP#0006 is <code>1,000 / (3 ^ (account_id.length - 2))</code> for cost per year.
This value represents <code>1,000</code> above adjusted to use per block</p>
<h1><a class="header" href="#runtimefeesconfig" id="runtimefeesconfig">RuntimeFeesConfig</a></h1>
<p>Economic parameters for runtime</p>
<h2><a class="header" href="#action_receipt_creation_config" id="action_receipt_creation_config">action_receipt_creation_config</a></h2>
<p><em>type: Fee</em></p>
<p>Describes the cost of creating an action receipt, <code>ActionReceipt</code>, excluding the actual cost
of actions.</p>
<h2><a class="header" href="#data_receipt_creation_config" id="data_receipt_creation_config">data_receipt_creation_config</a></h2>
<p><em>type: <a href="GenesisConfig/RuntimeFeeConfig/DataReceiptCreationConfig.html">DataReceiptCreationConfig</a></em></p>
<p>Describes the cost of creating a data receipt, <code>DataReceipt</code>.</p>
<h2><a class="header" href="#action_creation_config" id="action_creation_config">action_creation_config</a></h2>
<p><em>type: <a href="GenesisConfig/RuntimeFeeConfig/ActionCreationConfig.html">ActionCreationConfig</a></em></p>
<p>Describes the cost of creating a certain action, <code>Action</code>. Includes all variants.</p>
<h2><a class="header" href="#storage_usage_config" id="storage_usage_config">storage_usage_config</a></h2>
<p><em>type: <a href="GenesisConfig/RuntimeFeeConfig/StorageUsageConfig.html">StorageUsageConfig</a></em></p>
<p>Describes fees for storage rent</p>
<h2><a class="header" href="#burnt_gas_reward" id="burnt_gas_reward">burnt_gas_reward</a></h2>
<p><em>type: <a href="GenesisConfig/RuntimeFeeConfig/Fraction.html">Fraction</a></em></p>
<p>Fraction of the burnt gas to reward to the contract account for execution.</p>
<h1><a class="header" href="#accesskeycreationconfig" id="accesskeycreationconfig">AccessKeyCreationConfig</a></h1>
<p>Describes the cost of creating an access key.</p>
<h2><a class="header" href="#full_access_cost" id="full_access_cost">full_access_cost</a></h2>
<p><em>type: Fee</em>
Base cost of creating a full access access-key.</p>
<h2><a class="header" href="#function_call_cost" id="function_call_cost">function_call_cost</a></h2>
<p><em>type: Fee</em>
Base cost of creating an access-key restricted to specific functions.</p>
<h2><a class="header" href="#function_call_cost_per_byte" id="function_call_cost_per_byte">function_call_cost_per_byte</a></h2>
<p><em>type: Fee</em>
Cost per byte of method_names of creating a restricted access-key.</p>
<h1><a class="header" href="#action_creation_config-1" id="action_creation_config-1">action_creation_config</a></h1>
<p>Describes the cost of creating a specific action, <code>Action</code>. Includes all variants.</p>
<h2><a class="header" href="#create_account_cost" id="create_account_cost">create_account_cost</a></h2>
<p><em>type: Fee</em></p>
<p>Base cost of creating an account.</p>
<h2><a class="header" href="#deploy_contract_cost" id="deploy_contract_cost">deploy_contract_cost</a></h2>
<p><em>type: Fee</em></p>
<p>Base cost of deploying a contract.</p>
<h2><a class="header" href="#deploy_contract_cost_per_byte" id="deploy_contract_cost_per_byte">deploy_contract_cost_per_byte</a></h2>
<p><em>type: Fee</em></p>
<p>Cost per byte of deploying a contract.</p>
<h2><a class="header" href="#function_call_cost-1" id="function_call_cost-1">function_call_cost</a></h2>
<p><em>type: Fee</em></p>
<p>Base cost of calling a function.</p>
<h2><a class="header" href="#function_call_cost_per_byte-1" id="function_call_cost_per_byte-1">function_call_cost_per_byte</a></h2>
<p><em>type: Fee</em></p>
<p>Cost per byte of method name and arguments of calling a function.</p>
<h2><a class="header" href="#transfer_cost" id="transfer_cost">transfer_cost</a></h2>
<p><em>type: Fee</em></p>
<p>Base cost of making a transfer.</p>
<h2><a class="header" href="#stake_cost" id="stake_cost">stake_cost</a></h2>
<p><em>type: Fee</em></p>
<p>Base cost of staking.</p>
<h2><a class="header" href="#add_key_cost" id="add_key_cost">add_key_cost:</a></h2>
<p><em>type: <a href="GenesisConfig/RuntimeFeeConfig/AccessKeyCreationConfig.html">AccessKeyCreationConfig</a></em>
Base cost of adding a key.</p>
<h2><a class="header" href="#delete_key_cost" id="delete_key_cost">delete_key_cost</a></h2>
<p><em>type: Fee</em></p>
<p>Base cost of deleting a key.</p>
<h2><a class="header" href="#delete_account_cost" id="delete_account_cost">delete_account_cost</a></h2>
<p><em>type: Fee</em></p>
<p>Base cost of deleting an account.</p>
<h1><a class="header" href="#datareceiptcreationconfig" id="datareceiptcreationconfig">DataReceiptCreationConfig</a></h1>
<p>Describes the cost of creating a data receipt, <code>DataReceipt</code>.</p>
<h2><a class="header" href="#base_cost" id="base_cost">base_cost</a></h2>
<p><em>type: Fee</em>
Base cost of creating a data receipt.</p>
<h2><a class="header" href="#cost_per_byte" id="cost_per_byte">cost_per_byte</a></h2>
<p><em>type: Fee</em>
Additional cost per byte sent.</p>
<h1><a class="header" href="#storageusageconfig" id="storageusageconfig">StorageUsageConfig</a></h1>
<p>Describes cost of storage per block</p>
<h2><a class="header" href="#account_cost" id="account_cost">account_cost</a></h2>
<p><em>type: Gas</em>
Base storage usage for an account</p>
<h2><a class="header" href="#data_record_cost" id="data_record_cost">data_record_cost</a></h2>
<p><em>type: Gas</em>
Base cost for a k/v record</p>
<h2><a class="header" href="#key_cost_per_byte" id="key_cost_per_byte">key_cost_per_byte:</a></h2>
<p><em>type: Gas</em>
Cost per byte of key</p>
<h2><a class="header" href="#value_cost_per_byte-gas" id="value_cost_per_byte-gas">value_cost_per_byte: Gas</a></h2>
<p><em>type: Gas</em>
Cost per byte of value</p>
<h2><a class="header" href="#code_cost_per_byte-gas" id="code_cost_per_byte-gas">code_cost_per_byte: Gas</a></h2>
<p><em>type: Gas</em>
Cost per byte of contract code</p>
<h1><a class="header" href="#fee" id="fee">Fee</a></h1>
<p>Costs associated with an object that can only be sent over the network (and executed by the receiver).</p>
<h2><a class="header" href="#send_sir" id="send_sir">send_sir</a></h2>
<p>Fee for sending an object from the sender to itself, guaranteeing that it does not leave</p>
<h2><a class="header" href="#send_not_sir" id="send_not_sir">send_not_sir</a></h2>
<p>Fee for sending an object potentially across the shards.</p>
<h2><a class="header" href="#execution-1" id="execution-1">execution</a></h2>
<p>Fee for executing the object.</p>
<h1><a class="header" href="#fraction" id="fraction">Fraction</a></h1>
<h2><a class="header" href="#numerator" id="numerator">numerator</a></h2>
<p><em>type: u64</em></p>
<h2><a class="header" href="#denominator" id="denominator">denominator</a></h2>
<p><em>type: u64</em></p>
<h1><a class="header" href="#vmconfig" id="vmconfig">VMConfig</a></h1>
<p>Config of wasm operations.</p>
<h2><a class="header" href="#ext_costs" id="ext_costs">ext_costs:</a></h2>
<p><em>type: <a href="GenesisConfig/ExtCostsConfig.html">ExtCostsConfig</a></em></p>
<p>Costs for runtime externals</p>
<h2><a class="header" href="#grow_mem_cost" id="grow_mem_cost">grow_mem_cost</a></h2>
<p><em>type: u32</em></p>
<p>Gas cost of a growing memory by single page.</p>
<h2><a class="header" href="#regular_op_cost" id="regular_op_cost">regular_op_cost</a></h2>
<p><em>type: u32</em></p>
<p>Gas cost of a regular operation.</p>
<h2><a class="header" href="#max_gas_burnt" id="max_gas_burnt">max_gas_burnt</a></h2>
<p><em>type: Gas</em></p>
<p>Max amount of gas that can be used, excluding gas attached to promises.</p>
<h2><a class="header" href="#max_stack_height" id="max_stack_height">max_stack_height</a></h2>
<p><em>type: u32</em></p>
<p>How tall the stack is allowed to grow?</p>
<h2><a class="header" href="#initial_memory_pages" id="initial_memory_pages">initial_memory_pages</a></h2>
<p><em>type: u32</em></p>
<h2><a class="header" href="#max_memory_pages" id="max_memory_pages">max_memory_pages</a></h2>
<p><em>type: u32</em></p>
<p>The initial number of memory pages.
What is the maximal memory pages amount is allowed to have for
a contract.</p>
<h2><a class="header" href="#registers_memory_limit" id="registers_memory_limit">registers_memory_limit</a></h2>
<p><em>type: u64</em></p>
<p>Limit of memory used by registers.</p>
<h2><a class="header" href="#max_register_size" id="max_register_size">max_register_size</a></h2>
<p><em>type: u64</em></p>
<p>Maximum number of bytes that can be stored in a single register.</p>
<h2><a class="header" href="#max_number_registers" id="max_number_registers">max_number_registers</a></h2>
<p><em>type: u64</em></p>
<p>Maximum number of registers that can be used simultaneously.</p>
<h2><a class="header" href="#max_number_logs" id="max_number_logs">max_number_logs</a></h2>
<p><em>type: u64</em></p>
<p>Maximum number of log entries.</p>
<h2><a class="header" href="#max_log_len" id="max_log_len">max_log_len</a></h2>
<p><em>type: u64</em></p>
<p>Maximum length of a single log, in bytes.</p>
<h1><a class="header" href="#extcostsconfig" id="extcostsconfig">ExtCostsConfig</a></h1>
<h2><a class="header" href="#base" id="base">base</a></h2>
<p><em>type: Gas</em></p>
<p>Base cost for calling a host function.</p>
<h2><a class="header" href="#read_memory_base" id="read_memory_base">read_memory_base</a></h2>
<p><em>type: Gas</em></p>
<p>Base cost for guest memory read</p>
<h2><a class="header" href="#read_memory_byte" id="read_memory_byte">read_memory_byte</a></h2>
<p><em>type: Gas</em></p>
<p>Cost for guest memory read</p>
<h2><a class="header" href="#write_memory_base" id="write_memory_base">write_memory_base</a></h2>
<p><em>type: Gas</em></p>
<p>Base cost for guest memory write</p>
<h2><a class="header" href="#write_memory_byte" id="write_memory_byte">write_memory_byte</a></h2>
<p><em>type: Gas</em></p>
<p>Cost for guest memory write per byte</p>
<h2><a class="header" href="#read_register_base" id="read_register_base">read_register_base</a></h2>
<p><em>type: Gas</em></p>
<p>Base cost for reading from register</p>
<h2><a class="header" href="#read_register_byte" id="read_register_byte">read_register_byte</a></h2>
<p><em>type: Gas</em></p>
<p>Cost for reading byte from register</p>
<h2><a class="header" href="#write_register_base" id="write_register_base">write_register_base</a></h2>
<p><em>type: Gas</em></p>
<p>Base cost for writing into register</p>
<h2><a class="header" href="#write_register_byte" id="write_register_byte">write_register_byte</a></h2>
<p><em>type: Gas</em></p>
<p>Cost for writing byte into register</p>
<h2><a class="header" href="#utf8_decoding_base" id="utf8_decoding_base">utf8_decoding_base</a></h2>
<p><em>type: Gas</em></p>
<p>Base cost of decoding utf8.</p>
<h2><a class="header" href="#utf8_decoding_byte" id="utf8_decoding_byte">utf8_decoding_byte</a></h2>
<p><em>type: Gas</em></p>
<p>Cost per bye of decoding utf8.</p>
<h2><a class="header" href="#utf16_decoding_base" id="utf16_decoding_base">utf16_decoding_base</a></h2>
<p><em>type: Gas</em></p>
<p>Base cost of decoding utf16.</p>
<h2><a class="header" href="#utf16_decoding_byte" id="utf16_decoding_byte">utf16_decoding_byte</a></h2>
<p><em>type: Gas</em></p>
<p>Cost per bye of decoding utf16.</p>
<h2><a class="header" href="#sha256_base" id="sha256_base">sha256_base</a></h2>
<p><em>type: Gas</em></p>
<p>Cost of getting sha256 base</p>
<h2><a class="header" href="#sha256_byte" id="sha256_byte">sha256_byte</a></h2>
<p><em>type: Gas</em></p>
<p>Cost of getting sha256 per byte</p>
<h2><a class="header" href="#keccak256_base" id="keccak256_base">keccak256_base</a></h2>
<p><em>type: Gas</em></p>
<p>Cost of getting keccak256 base</p>
<h2><a class="header" href="#keccak256_byte" id="keccak256_byte">keccak256_byte</a></h2>
<p><em>type: Gas</em></p>
<p>Cost of getting keccak256 per byte</p>
<h2><a class="header" href="#keccak512_base" id="keccak512_base">keccak512_base</a></h2>
<p><em>type: Gas</em></p>
<p>Cost of getting keccak512 base</p>
<h2><a class="header" href="#keccak512_byte" id="keccak512_byte">keccak512_byte</a></h2>
<p><em>type: Gas</em></p>
<p>Cost of getting keccak512 per byte</p>
<h2><a class="header" href="#log_base" id="log_base">log_base</a></h2>
<p><em>type: Gas</em></p>
<p>Cost for calling logging.</p>
<h2><a class="header" href="#log_byte" id="log_byte">log_byte</a></h2>
<p><em>type: Gas</em></p>
<p>Cost for logging per byte</p>
<h2><a class="header" href="#storage-api" id="storage-api">Storage API</a></h2>
<h3><a class="header" href="#storage_write_base" id="storage_write_base">storage_write_base</a></h3>
<p><em>type: Gas</em></p>
<p>Storage trie write key base cost</p>
<h3><a class="header" href="#storage_write_key_byte" id="storage_write_key_byte">storage_write_key_byte</a></h3>
<p><em>type: Gas</em></p>
<p>Storage trie write key per byte cost</p>
<h3><a class="header" href="#storage_write_value_byte" id="storage_write_value_byte">storage_write_value_byte</a></h3>
<p><em>type: Gas</em></p>
<p>Storage trie write value per byte cost</p>
<h3><a class="header" href="#storage_write_evicted_byte" id="storage_write_evicted_byte">storage_write_evicted_byte</a></h3>
<p><em>type: Gas</em></p>
<p>Storage trie write cost per byte of evicted value.</p>
<h3><a class="header" href="#storage_read_base" id="storage_read_base">storage_read_base</a></h3>
<p><em>type: Gas</em></p>
<p>Storage trie read key base cost</p>
<h3><a class="header" href="#storage_read_key_byte" id="storage_read_key_byte">storage_read_key_byte</a></h3>
<p><em>type: Gas</em></p>
<p>Storage trie read key per byte cost</p>
<h3><a class="header" href="#storage_read_value_byte" id="storage_read_value_byte">storage_read_value_byte</a></h3>
<p><em>type: Gas</em></p>
<p>Storage trie read value cost per byte cost</p>
<h3><a class="header" href="#storage_remove_base" id="storage_remove_base">storage_remove_base</a></h3>
<p><em>type: Gas</em></p>
<p>Remove key from trie base cost</p>
<h3><a class="header" href="#storage_remove_key_byte" id="storage_remove_key_byte">storage_remove_key_byte</a></h3>
<p><em>type: Gas</em></p>
<p>Remove key from trie per byte cost</p>
<h3><a class="header" href="#storage_remove_ret_value_byte" id="storage_remove_ret_value_byte">storage_remove_ret_value_byte</a></h3>
<p><em>type: Gas</em></p>
<p>Remove key from trie ret value byte cost</p>
<h3><a class="header" href="#storage_has_key_base" id="storage_has_key_base">storage_has_key_base</a></h3>
<p><em>type: Gas</em></p>
<p>Storage trie check for key existence cost base</p>
<h3><a class="header" href="#storage_has_key_byte" id="storage_has_key_byte">storage_has_key_byte</a></h3>
<p><em>type: Gas</em></p>
<p>Storage trie check for key existence per key byte</p>
<h3><a class="header" href="#storage_iter_create_prefix_base" id="storage_iter_create_prefix_base">storage_iter_create_prefix_base</a></h3>
<p><em>type: Gas</em></p>
<p>Create trie prefix iterator cost base</p>
<h3><a class="header" href="#storage_iter_create_prefix_byte" id="storage_iter_create_prefix_byte">storage_iter_create_prefix_byte</a></h3>
<p><em>type: Gas</em></p>
<p>Create trie prefix iterator cost per byte.</p>
<h3><a class="header" href="#storage_iter_create_range_base" id="storage_iter_create_range_base">storage_iter_create_range_base</a></h3>
<p><em>type: Gas</em></p>
<p>Create trie range iterator cost base</p>
<h3><a class="header" href="#storage_iter_create_from_byte" id="storage_iter_create_from_byte">storage_iter_create_from_byte</a></h3>
<p><em>type: Gas</em></p>
<p>Create trie range iterator cost per byte of from key.</p>
<h3><a class="header" href="#storage_iter_create_to_byte" id="storage_iter_create_to_byte">storage_iter_create_to_byte</a></h3>
<p><em>type: Gas</em></p>
<p>Create trie range iterator cost per byte of to key.</p>
<h3><a class="header" href="#storage_iter_next_base" id="storage_iter_next_base">storage_iter_next_base</a></h3>
<p><em>type: Gas</em></p>
<p>Trie iterator per key base cost</p>
<h3><a class="header" href="#storage_iter_next_key_byte" id="storage_iter_next_key_byte">storage_iter_next_key_byte</a></h3>
<p><em>type: Gas</em></p>
<p>Trie iterator next key byte cost</p>
<h3><a class="header" href="#storage_iter_next_value_byte" id="storage_iter_next_value_byte">storage_iter_next_value_byte</a></h3>
<p><em>type: Gas</em></p>
<p>Trie iterator next key byte cost</p>
<h3><a class="header" href="#touching_trie_node" id="touching_trie_node">touching_trie_node</a></h3>
<p><em>type: Gas</em></p>
<p>Cost per touched trie node</p>
<h2><a class="header" href="#promise-api" id="promise-api">Promise API</a></h2>
<h3><a class="header" href="#promise_and_base" id="promise_and_base">promise_and_base</a></h3>
<p><em>type: Gas</em></p>
<p>Cost for calling promise_and</p>
<h3><a class="header" href="#promise_and_per_promise" id="promise_and_per_promise">promise_and_per_promise</a></h3>
<p><em>type: Gas</em></p>
<p>Cost for calling promise_and for each promise</p>
<h3><a class="header" href="#promise_return" id="promise_return">promise_return</a></h3>
<p><em>type: Gas</em></p>
<p>Cost for calling promise_return</p>
<h1><a class="header" href="#economics" id="economics">Economics</a></h1>
<p><strong>This is under heavy development</strong></p>
<h2><a class="header" href="#units" id="units">Units</a></h2>
<table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td>yoctoNEAR</td><td>smallest undividable amount of native currency <em>NEAR</em>.</td></tr>
<tr><td>NEAR</td><td><code>10**24</code> yoctoNEAR</td></tr>
<tr><td>block</td><td>smallest on-chain unit of time</td></tr>
<tr><td>gas</td><td>unit to measure usage of blockchain</td></tr>
</tbody></table>
<h2><a class="header" href="#general-parameters" id="general-parameters">General Parameters</a></h2>
<table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td><code>INITIAL_SUPPLY</code></td><td><code>10**33</code> yoctoNEAR</td></tr>
<tr><td><code>NEAR</code></td><td><code>10**24</code> yoctoNEAR</td></tr>
<tr><td><code>REWARD_PCT_PER_YEAR</code></td><td><code>0.05</code></td></tr>
<tr><td><code>BLOCK_TIME</code></td><td><code>1</code> second</td></tr>
<tr><td><code>EPOCH_LENGTH</code></td><td><code>43,200</code> blocks</td></tr>
<tr><td><code>EPOCHS_A_YEAR</code></td><td><code>730</code> epochs</td></tr>
<tr><td><code>POKE_THRESHOLD</code></td><td><code>500</code> blocks</td></tr>
<tr><td><code>STORAGE_PRICE</code></td><td><code>7E-15</code> NEAR per byte per block</td></tr>
<tr><td><code>TREASURY_PCT</code></td><td><code>0.1</code></td></tr>
<tr><td><code>CONTRACT_PCT</code></td><td><code>0.3</code></td></tr>
<tr><td><code>INVALID_STATE_SLASH_PCT</code></td><td><code>0.05</code></td></tr>
<tr><td><code>ADJ_FEE</code></td><td><code>0.001</code></td></tr>
<tr><td><code>TREASURY_ACCOUNT_ID</code></td><td><code>treasury</code></td></tr>
<tr><td><code>TREASURY_PCT</code></td><td><code>0.01</code></td></tr>
</tbody></table>
<h2><a class="header" href="#general-variables" id="general-variables">General Variables</a></h2>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>total_supply[t]</code></td><td>Total supply of NEAR at given epoch[t]</td></tr>
<tr><td><code>gasPrice</code></td><td>The cost of 1 unit of <em>gas</em> in NEAR tokens (see Transaction Fees section below)</td></tr>
</tbody></table>
<h2><a class="header" href="#issuance" id="issuance">Issuance</a></h2>
<p>The protocol sets a ceiling for the maximum issuance of tokens, and dynamically decreases this issuance depending on the amount of total fees in the system.</p>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>reward[t]</code></td><td><code>totalSupply[t]</code> * ((<code>1 - REWARD_PCT_PER_YEAR</code>) ** (<code>1/EPOCHS_A_YEAR</code>) - <code>1</code>)</td></tr>
<tr><td><code>epochFee[t]</code></td><td><code>sum([(1 - DEVELOPER_PCT_PER_YEAR) * block.txFee + block.stateFee for block in epoch[t]])</code></td></tr>
<tr><td><code>issuance[t]</code></td><td>The amount of token issued at a certain epoch[t], <code>issuance[t] = reward[t] - epochFee[t]</code></td></tr>
</tbody></table>
<p>Where <code>totalSupply[t]</code> is the total number of tokens in the system at a given time <em>t</em>.
If <code>epochFee[t] &gt; reward[t]</code> the issuance is negative, thus the <code>totalSupply[t]</code> decreases in given epoch.</p>
<h2><a class="header" href="#transaction-and-storage-fees" id="transaction-and-storage-fees">Transaction and Storage Fees</a></h2>
<p>All state fees and most of transaction fees get burned.</p>
<h3><a class="header" href="#transaction-fees" id="transaction-fees">Transaction Fees</a></h3>
<p>Each transaction before inclusion must buy gas enough to cover the cost of bandwidth and execution.</p>
<p>Gas unifies execution and bytes of bandwidth usage of blockchain. Each WASM instruction or pre-compiled function gets assigned an amount of gas based on measurements on common-denominator computer. Same goes for weighting the used bandwidth based on general unified costs. For specific gas mapping numbers see <a href="Economics/">???</a>.</p>
<p>Gas is priced dynamically in <code>NEAR</code> tokens. At each block <code>t</code>, we update <code>gasPrice[t] = gasPrice[t - 1] * (gasUsed[t - 1] / gasLimit[t - 1] - 0.5) * ADJ_FEE</code>.</p>
<p>Where <code>gasUsed[t] = sum([sum([gas(tx) for tx in chunk]) for chunk in block[t]])</code>.
<code>gasLimit[t]</code> is defined as <code>gasLimit[t] = gasLimit[t - 1] + validatorGasDiff[t - 1]</code>, where <code>validatorGasDiff</code> is parameter with which each chunk producer can either increase or decrease gas limit based on how long it to execute the previous chunk. <code>validatorGasDiff[t]</code> can be only within <code>±0.1%</code> of <code>gasLimit[t]</code> and only if <code>gasUsed[t - 1] &gt; 0.9 * gasLimit[t - 1]</code>.</p>
<h3><a class="header" href="#state-storage-rent" id="state-storage-rent">State Storage Rent</a></h3>
<p>At every block time, each account is charged an amount of <code>NEAR</code> tokens proportional to their storage footprint, commonly defined as <em>state rent</em>.</p>
<pre><code class="language-python"># Before account touched / changed, we check that it has enough to pay fees.
# This will fail on any transaction that touches such an account.
def before_acccount_change(block_height, account):
    maxFee = sizeOf(account) * storagePrice * pokeThreshold
    # Check that current amount is enough to cover at least `pokeThreshold` of blocks.
    if maxFee &gt;= account.amount:
        assert &quot;Can't modify under funded account&quot;

# After account touched / changed, we charge the storage fee.
def on_account_change(block_height, account):
    # Compute fee since last charging state rent (last call this function).
    fee = sizeOf(account) * storagePrice * (block_height - account.storagePaidAt)
    account.amount -= fee
    account.storagePaidAt = block_height

# Can delete underfunded account by anyone.
def can_delete_account(block_height, account):
    maxFee = sizeOf(account) * storagePrice * pokeThreshold
    if maxFee &lt; account.amount:
        assert &quot;Account still has enough funds&quot;
    # Return to caller the rest of the amonut after charging fees.
    owedFee = sizeOf(account) * storagePrice * (block_height - account.storagePaidAt)
    return account.amount - owedFee
</code></pre>
<p>Where <code>sizeOf(account)</code> includes size of <code>account</code> structure and size of all the data stored under the account.</p>
<p>When <code>account</code> is staking, if <code>account.amount &lt; 4 * epochLength * storagePrice * sizeOf(account)</code>, the staking transaction fill fail or existing staking proposal will not be accepted for a rollover in the next epoch (see below in the Validator section)</p>
<h2><a class="header" href="#validators-2" id="validators-2">Validators</a></h2>
<p>NEAR validators provide their resources in exchange for a reward <code>epochReward[t]</code>, where [t] represents the considered epoch</p>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>epochReward[t]</code></td><td><code>= coinbaseReward[t] + epochFee[t]</code></td></tr>
<tr><td><code>coinbaseReward[t]</code></td><td>The maximum inflation per epoch[t], as a function of <code>REWARD_PCT_PER_YEAR / EPOCHS_A_YEAR</code></td></tr>
</tbody></table>
<h3><a class="header" href="#validator-selection" id="validator-selection">Validator Selection</a></h3>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>proposals</code></td><td>The array of all existing validators, minus the ones which were online less than <code>ONLINE_THRESHOLD</code>, plus new validators</td></tr>
<tr><td><code>INCLUSION_FEE</code></td><td>The arbitrary transaction fee that new validators offer to be included in the <code>proposals</code>, to mitigate censorship risks by existing validators</td></tr>
<tr><td><code>ONLINE_THRESHOLD</code></td><td><code>0.9</code></td></tr>
<tr><td><code>epoch[T]</code></td><td>The epoch when validator[v] is selected from the <code>proposals</code> auction array</td></tr>
<tr><td><code>seatPrice</code></td><td>The minimum stake needed to become validator in epoch[T]</td></tr>
<tr><td><code>stake[v]</code></td><td>The amount in NEAR tokens staked by validator[v] during the auction at the end of epoch[T-2], minus <code>INCLUSION_FEE</code></td></tr>
<tr><td><code>shard[v]</code></td><td>The shard is randomly assigned to validator[v] at epoch[T-1], such that its node can download and sync with its state</td></tr>
<tr><td><code>numSeats</code></td><td>Number of seats assigned to validator[v], calculated from stake[v]/seatPrice</td></tr>
<tr><td><code>validatorAssignments</code></td><td>The resulting ordered array of all <code>proposals</code> with a stake higher than <code>seatPrice</code></td></tr>
</tbody></table>
<p><code>validatorAssignments</code> is then split in two groups: block/chunk producers and 'hidden validators'</p>
<h3><a class="header" href="#rewards-calculation" id="rewards-calculation">Rewards Calculation</a></h3>
<table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td><code>epochFee[t]</code></td><td><code>sum([(1 - DEVELOPER_PCT_PER_YEAR) * txFee[i] + stateFee[i] for i in epoch[t]])</code>, where [i] represents any considered block within the epoch[t]</td></tr>
</tbody></table>
<p>Total reward every epoch <code>t</code> is equal to:</p>
<pre><code class="language-python">reward[t] = total_supply * ((1 + REWARD_PCT_PER_YEAR) ** (1 / EPOCHS_A_YEAR) - 1)
</code></pre>
<p>Uptime of a specific validator is computed:</p>
<pre><code class="language-python">median_produced_blocks[t] = median(num_produced_blocks[t])

pct_produced_blocks[t][j] = num_produced_blocks[t][j] * median_produced_blocks[t]
if pct_produced_blocks &gt; ONLINE_THRESHOLD:
    uptime[t][j] = (pct_produced_blocks[t][j] - ONLINE_THRESHOLD) / (1 - ONLINE_THRESHOLD)
else:
    uptime[t][j] = 0
</code></pre>
<p>The specific <code>validator[t]</code> reward for epoch <code>j</code> is then computed:</p>
<pre><code class="language-python">validator[t][j] = uptime[t][j] * reward[t] / total_seats * seats[j]
</code></pre>
<h3><a class="header" href="#slashing" id="slashing">Slashing</a></h3>
<h4><a class="header" href="#block-double-sign" id="block-double-sign">Block Double Sign</a></h4>
<pre><code class="language-python"># Check if given two blocks headers have the same height and 
# are valid (signed by the same validator).
def block_double_sign_condition(header1, header2):
    return valid_header(header1) and valid_header(heade2) and header1.height == header2.height

# At the end of the epoch, run update validators and 
# determine how much to slash validators.
def end_of_epoch_update_validators(validators):
    # ...
    total_stake = 0
    total_offended_stake = 0
    for validator in validators:
        total_stake += validator.stake
        if validator.is_slashed:
            total_offended_stake += validator.stake
    for validator in validators:
        if validator.is_slashed:
            validator.stake -= validator.stake * 3 * total_offended_stake / total_stake
</code></pre>
<h4><a class="header" href="#chunkproofs" id="chunkproofs">ChunkProofs</a></h4>
<pre><code class="language-python"># Check that chunk is invalid, because the proofs in header don't match the body.
def chunk_proofs_condition(chunk):
    # TODO

# At the end of the epoch, run update validators and
# determine how much to slash validators.
def end_of_epoch_update_validators(validators):
    # ...
    for validator in validators:
        if validator.is_slashed:
            validator.stake -= INVALID_STATE_SLASH_PCT * validator.stake
</code></pre>
<h4><a class="header" href="#chunkstate" id="chunkstate">ChunkState</a></h4>
<pre><code class="language-python"># Check that chunk header post state root is invalid, 
# because the execution of previous chunk doesn't lead to it.
def chunk_state_condition(prev_chunk, prev_state, chunk_header):
    # TODO

# At the end of the epoch, run update validators and
# determine how much to slash validators.
def end_of_epoch(..., validators):
    # ...
    for validator in validators:
        if validator.is_slashed:
            validator.stake -= INVALID_STATE_SLASH_PCT * validator.stake
</code></pre>
<h2><a class="header" href="#protocol-treasury" id="protocol-treasury">Protocol Treasury</a></h2>
<p>Treasury account <code>TREASURY_ACCOUNT_ID</code> receives fraction of reward every epoch <code>t</code>:</p>
<pre><code class="language-python"># At the end of the epoch, update treasury
def end_of_epoch(..., reward):
    # ...
    accounts[TREASURY_ACCOUNT_ID].amount = TREASURY_PCT * reward
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
